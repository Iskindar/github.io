<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"iskindar.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="KLEE 源码阅读笔记前言KLEE是基于LLVM的符号执行工具，发表于2008年的OSDI会议上，至今已被引用3000多次，基于该工作的研究也有150多篇，其中有30多个是开源工作。本文从KLEE源码入手，希望能让读者了解klee工作的基本原理。 1. klee 基本框架KLEE是EXE工作的重新设计。从高层面来说，KLEE像一个符号化进程的操作系统和解释器。程序源码被LLVM编译为类似RISC的">
<meta property="og:type" content="article">
<meta property="og:title" content="KLEE 源码阅读笔记">
<meta property="og:url" content="http://iskindar.github.io/2021/05/20/KLEE%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="iskindar的博客">
<meta property="og:description" content="KLEE 源码阅读笔记前言KLEE是基于LLVM的符号执行工具，发表于2008年的OSDI会议上，至今已被引用3000多次，基于该工作的研究也有150多篇，其中有30多个是开源工作。本文从KLEE源码入手，希望能让读者了解klee工作的基本原理。 1. klee 基本框架KLEE是EXE工作的重新设计。从高层面来说，KLEE像一个符号化进程的操作系统和解释器。程序源码被LLVM编译为类似RISC的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20210505204501326.png">
<meta property="og:image" content="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20210505195953723.png">
<meta property="article:published_time" content="2021-05-20T08:30:00.000Z">
<meta property="article:modified_time" content="2023-08-14T07:46:44.625Z">
<meta property="article:author" content="iskindar">
<meta property="article:tag" content="symbolic execution">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20210505204501326.png">

<link rel="canonical" href="http://iskindar.github.io/2021/05/20/KLEE%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>KLEE 源码阅读笔记 | iskindar的博客</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?9a79db5615c4a0bf77e512dd81c44895";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">iskindar的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Into the Night !</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/iskindar" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://iskindar.github.io/2021/05/20/KLEE%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/20220530182402_fa7aa.jpeg">
      <meta itemprop="name" content="iskindar">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="iskindar的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          KLEE 源码阅读笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-20 16:30:00" itemprop="dateCreated datePublished" datetime="2021-05-20T16:30:00+08:00">2021-05-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-14 15:46:44" itemprop="dateModified" datetime="2023-08-14T15:46:44+08:00">2023-08-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="KLEE-源码阅读笔记"><a href="#KLEE-源码阅读笔记" class="headerlink" title="KLEE 源码阅读笔记"></a>KLEE 源码阅读笔记</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>KLEE是基于LLVM的符号执行工具，发表于2008年的OSDI会议上，至今已被引用3000多次，基于该工作的研究也有150多篇，其中有30多个是开源工作。本文从KLEE源码入手，希望能让读者了解klee工作的基本原理。</p>
<h2 id="1-klee-基本框架"><a href="#1-klee-基本框架" class="headerlink" title="1. klee 基本框架"></a>1. klee 基本框架</h2><p>KLEE是EXE工作的重新设计。从高层面来说，KLEE像一个符号化进程的操作系统和解释器。程序源码被LLVM编译为类似RISC的虚拟指令集，KLEE直接解释指令，并将指令映射为约束条件。</p>
<p>KLEE的核心是一个解释器，循环地从状态池里选择状态，并在那个状态下符号化地执行每条指令。直到状态池里没有状态了，或者时间超过了用户设定的。</p>
<p>符号执行引擎存储的状态的寄存器、栈或者堆对象，都是表达式形式的，而非普通进程里的具体值。表达式的叶子节点是符号化的变量或者常量。还可以是LLVM中间层语言操作（算术运算、比较、内存访问）的内部节点。</p>
<p>符号执行大部分的指令都很直接。比如要符号执行一个LLVM加法运算。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%dst = add i32 %src0, %src1</span><br></pre></td></tr></table></figure>

<p>KLEE直接从src0和src1里取出加数，并且写一个新的表达式Add(%src0,%src1)到dst寄存器里。如果操作数都是具体值，就直接加好，返回一个常数表达式。</p>
<p>条件分支是布尔表达式，并且会根据条件为真或假改变状态的指令指针。KLEE去查询约束求解器来确定当前路径上的分支条件是否恒为真或假。如果恒为真或假，就更新指令指针到预计的位置。反之两种分支都有可能。然后KLEE就会去复制当前状态，这样就可以同时探索两条路径，并且同时更新指令指针和路径条件。</p>
<p>潜在的危险操作也会生成一个分支。比如一个除法操作就会生成一个分支去检测除数是不是0。这些分支的工作方式和普通分支是一样的。当检查成功，即检测出错误的时候，会继续执行条件为假的路径，也就是添加相反的约束，比如使得除数不为0的约束。此外，还会为错误生成测试样例，并且终止检测出错误的状态。</p>
<p>至于其他的危险操作，比如load和store指令，也会去检查。这些例子里，就会去检查地址是不是在合法内存对象里。然而，store和load指令需要额外的编译。最直接的表示内存的方式是flat byte array。这种情况下，load和store就会分别简单地映射为数组读和写表达式。</p>
<p>然而，KLEE使用的约束求解器不能解决这种约束。于是，KLEE将每个要检查代码的内存对象映射到一个单独的STP数组里。这种方式提高了性能，因为这让STP无视了表达式没有引用的数组。</p>
<p>许多操作比如边界检查，对象级的copy-on-write）需要对象特定的信息。如果一个指针指向很多对象，这些操作就很难实现。为了简化实现，KLEE用以下方式回避了这个问题。当一个解引用的指针p指向N个对象时，KLEE复制当前状态N次。在每个状态，KLEE限制指针p在其对象的边界内，然后实现读或写操作。虽然这个方法对于有很大points-to 集合的指针的开销很大，但实际情况中，大部分的符号指针只指向1个对象，所以这个优化还是可以的。</p>
<h2 id="2-klee代码架构"><a href="#2-klee代码架构" class="headerlink" title="2. klee代码架构"></a>2. klee代码架构</h2><p>从klee官网的开发者指南，我们可以知道klee源码的大致结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">|-- include //包含公共的头文件</span><br><span class="line">|-- tools //所有KLEE的二进制的main都在这里，有些是python脚本</span><br><span class="line">|-- lib //包含大部分的源码</span><br><span class="line">|   |-- Core //包含解释和执行LLVM字节码和KLEE内存模型。</span><br><span class="line">|   |-- Expr // klee的表达式库</span><br><span class="line">|   |-- Module //包含在执行LLVM字节码前的一些操作代码。比如链接POSIX运行函数等等。</span><br><span class="line">|   |-- Solver//包含所有求解器</span><br><span class="line">|-- runtime//包含各种KLEE的运行时支持。</span><br><span class="line">|-- test//包含一些小的C程序和LLVM的字节码，用来给KLEE做回归测试</span><br></pre></td></tr></table></figure>

<p>由上面的结构可以知道，如果要修改KLEE的话，基本上是在lib&#x2F;core目录下进行修改。现在看看lib&#x2F;core目录下都有哪些代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">|-- AddressSpace.cpp</span><br><span class="line">|-- AddressSpace.h</span><br><span class="line">|-- CallPathManager.cpp</span><br><span class="line">|-- CallPathManager.h</span><br><span class="line">|-- Context.cpp</span><br><span class="line">|-- Context.h</span><br><span class="line">|-- CoreStats.cpp</span><br><span class="line">|-- CoreStats.h</span><br><span class="line">|-- ExecutionState.cpp</span><br><span class="line">|-- ExecutionState.h</span><br><span class="line">|-- Executor.cpp</span><br><span class="line">|-- Executor.h</span><br><span class="line">|-- ExecutorUtil.cpp</span><br><span class="line">|-- ExternalDispatcher.cpp</span><br><span class="line">|-- ExternalDispatcher.h</span><br><span class="line">|-- GetElementPtrTypeIterator.h</span><br><span class="line">|-- ImpliedValue.cpp</span><br><span class="line">|-- ImpliedValue.h</span><br><span class="line">|-- Memory.cpp</span><br><span class="line">|-- Memory.h</span><br><span class="line">|-- MemoryManager.cpp</span><br><span class="line">|-- MemoryManager.h</span><br><span class="line">|-- MergeHandler.cpp</span><br><span class="line">|-- MergeHandler.h</span><br><span class="line">|-- PTree.cpp</span><br><span class="line">|-- PTree.h</span><br><span class="line">|-- Searcher.cpp</span><br><span class="line">|-- Searcher.h</span><br><span class="line">|-- SeedInfo.cpp</span><br><span class="line">|-- SeedInfo.h</span><br><span class="line">|-- SpecialFunctionHandler.cpp</span><br><span class="line">|-- SpecialFunctionHandler.h</span><br><span class="line">|-- StatsTracker.cpp</span><br><span class="line">|-- StatsTracker.h</span><br><span class="line">|-- TimingSolver.cpp</span><br><span class="line">|-- TimingSolver.h</span><br><span class="line">|-- UserSearcher.cpp</span><br><span class="line">|-- UserSearcher.h</span><br></pre></td></tr></table></figure>

<p>咋看上去有一点多。去掉头文件就少一半，大概将近二十个代码。这里我们就先从Executor.cpp这里开始看，这里也是解释器的主循环所在的代码。</p>
<h2 id="3-klee的执行器Executor"><a href="#3-klee的执行器Executor" class="headerlink" title="3. klee的执行器Executor"></a>3. klee的执行器Executor</h2><p>解释器的主循环代码位于Executor.cpp的run函数里。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Executor::run</span><span class="params">(ExecutionState &amp;initialState)</span> &#123;</span><br><span class="line">  bindModuleConstants();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Delay init till now so that ticks don&#x27;t accrue during optimization and such.</span></span><br><span class="line">  timers.reset();</span><br><span class="line"></span><br><span class="line">  states.insert(&amp;initialState);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (usingSeeds) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  searcher = constructUserSearcher(*this);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;ExecutionState *&gt; <span class="title function_">newStates</span><span class="params">(states.begin(), states.end())</span>;</span><br><span class="line">  searcher-&gt;update(<span class="number">0</span>, newStates, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;ExecutionState *&gt;());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// main interpreter loop</span></span><br><span class="line">  <span class="keyword">while</span> (!states.empty() &amp;&amp; !haltExecution) &#123;</span><br><span class="line">    ExecutionState &amp;state = searcher-&gt;selectState();</span><br><span class="line">    KInstruction *ki = state.pc;</span><br><span class="line">    stepInstruction(state);</span><br><span class="line"></span><br><span class="line">    executeInstruction(state, ki);</span><br><span class="line">    timers.invoke();</span><br><span class="line">    <span class="keyword">if</span> (::dumpStates) dumpStates();</span><br><span class="line">    <span class="keyword">if</span> (::dumpPTree) dumpPTree();</span><br><span class="line"></span><br><span class="line">    updateStates(&amp;state);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!checkMemoryUsage()) &#123;</span><br><span class="line">      <span class="comment">// update searchers when states were terminated early due to memory pressure</span></span><br><span class="line">      updateStates(nullptr);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码注释&#x2F;&#x2F;main  interpreter loop往下看，代码的逻辑基本和前面说的差不多，由搜索器searcher选择一个状态，然后执行指令，并且更新状态。下面我们来看组成这个循环的四个主要函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">selectState();</span><br><span class="line">stepInstruction(state);</span><br><span class="line">executeInstruction(state, ki);</span><br><span class="line">updateStates(&amp;state);</span><br></pre></td></tr></table></figure>

<p>将run函数的大致流程可以用下图表示。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20210505204501326.png" alt="image-20210505204501326"></p>
<p>selectState函数在Searcher.cpp里，并且每种search的选择状态实现也不一样。比如DFSSearcer就直接返回状态池的最后一个状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExecutionState &amp;DFSSearcher::selectState() &#123;</span><br><span class="line">  return *states.back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BFSSearcher返回第一个状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExecutionState &amp;BFSSearcher::selectState() &#123;</span><br><span class="line">  return *states.front();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>KLEE还实现了很多Searcher，感兴趣地可以去Searcher.cpp代码里看。</p>
<p>下面的代码是stepInstruction，逻辑比较简单，主要就是将PC+1。并且判断一下如果指令数量到达最大指令数量，就将haltExecution标志位置为真。为什么不直接将这个逻辑整合到执行指令里去呢？除了要判断指令的数目这点外，也是为了更好地扩展。实际上就有工作在stepInstuction和executeInstruction之间做了扩展，比如基于klee扩展的一个工作BovInspector就在此处加了一个验证函数BFO_Check函数来验证缓冲区溢出漏洞。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void Executor::stepInstruction(ExecutionState &amp;state) &#123;</span><br><span class="line">  printDebugInstructions(state);</span><br><span class="line">  if (statsTracker)</span><br><span class="line">    statsTracker-&gt;stepInstruction(state);</span><br><span class="line"></span><br><span class="line">  ++stats::instructions;</span><br><span class="line">  ++state.steppedInstructions;</span><br><span class="line">  state.prevPC = state.pc;</span><br><span class="line">  ++state.pc;</span><br><span class="line"></span><br><span class="line">  if (stats::instructions == MaxInstructions)</span><br><span class="line">    haltExecution = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是executeInstruction()函数，这个函数代码量比较大，核心就是一个很大的switch语句，对于不同的指令，设置了不同的执行方式。下图展示了KLEE建模的指令。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20210505195953723.png" alt="image-20210505195953723"></p>
<p>下面代码节选了内存指令的实现。eval函数的作用是求解表达式。对angr有了解的，可能会发现angr里也有eval这个接口。这部分对指令的建模代码看起来有点晦涩，但大体上可以看出klee对IR层的每条指令都做了细致的处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void Executor::executeInstruction(ExecutionState &amp;state, KInstruction *ki) &#123;</span><br><span class="line">  Instruction *i = ki-&gt;inst;</span><br><span class="line">  switch (i-&gt;getOpcode()) &#123;</span><br><span class="line">  ...</span><br><span class="line">   case Instruction::Alloca: &#123;</span><br><span class="line">    AllocaInst *ai = cast&lt;AllocaInst&gt;(i);</span><br><span class="line">    unsigned elementSize = </span><br><span class="line">      kmodule-&gt;targetData-&gt;getTypeStoreSize(ai-&gt;getAllocatedType());</span><br><span class="line">    ref&lt;Expr&gt; size = Expr::createPointer(elementSize);</span><br><span class="line">    if (ai-&gt;isArrayAllocation()) &#123;</span><br><span class="line">      ref&lt;Expr&gt; count = eval(ki, 0, state).value;</span><br><span class="line">      count = Expr::createZExtToPointerWidth(count);</span><br><span class="line">      size = MulExpr::create(size, count);</span><br><span class="line">    &#125;</span><br><span class="line">    executeAlloc(state, size, true, ki);</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  case Instruction::Load: &#123;</span><br><span class="line">    ref&lt;Expr&gt; base = eval(ki, 0, state).value;</span><br><span class="line">    executeMemoryOperation(state, false, base, 0, ki);</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line">  case Instruction::Store: &#123;</span><br><span class="line">    ref&lt;Expr&gt; base = eval(ki, 1, state).value;</span><br><span class="line">    ref&lt;Expr&gt; value = eval(ki, 0, state).value;</span><br><span class="line">    executeMemoryOperation(state, true, base, value, 0);</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p>接下来看更新状态的代码。主要逻辑就是把addedStates的状态加到状态池里，removedStates的状态移出状态池里。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void Executor::updateStates(ExecutionState *current) &#123;</span><br><span class="line">  if (searcher) &#123;</span><br><span class="line">    searcher-&gt;update(current, addedStates, removedStates);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  states.insert(addedStates.begin(), addedStates.end());</span><br><span class="line">  addedStates.clear();</span><br><span class="line"></span><br><span class="line">  for (std::vector&lt;ExecutionState *&gt;::iterator it = removedStates.begin(),</span><br><span class="line">                                               ie = removedStates.end();</span><br><span class="line">       it != ie; ++it) &#123;</span><br><span class="line">    ExecutionState *es = *it;</span><br><span class="line">    std::set&lt;ExecutionState*&gt;::iterator it2 = states.find(es);</span><br><span class="line">    assert(it2!=states.end());</span><br><span class="line">    states.erase(it2);</span><br><span class="line">    std::map&lt;ExecutionState*, std::vector&lt;SeedInfo&gt; &gt;::iterator it3 = </span><br><span class="line">      seedMap.find(es);</span><br><span class="line">    if (it3 != seedMap.end())</span><br><span class="line">      seedMap.erase(it3);</span><br><span class="line">    processTree-&gt;remove(es-&gt;ptreeNode);</span><br><span class="line">    delete es;</span><br><span class="line">  &#125;</span><br><span class="line">  removedStates.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-klee的状态"><a href="#4-klee的状态" class="headerlink" title="4. klee的状态"></a>4. klee的状态</h2><p>从Executor.cpp的代码里，我们可以发现，klee里一个很重要的概念就是state。解释器里的几个重要流程的操作对象都是状态。接下来看看klee的状态都有哪些部分组成。这部分代码在ExecutionState.cpp。从下面的代码中，可以发现状态里包含了很多信息，包括pc，栈约束条件等等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ExecutionState::ExecutionState(const ExecutionState&amp; state):</span><br><span class="line">    pc(state.pc),</span><br><span class="line">    prevPC(state.prevPC),</span><br><span class="line">    stack(state.stack),</span><br><span class="line">    incomingBBIndex(state.incomingBBIndex),</span><br><span class="line">    depth(state.depth),</span><br><span class="line">    addressSpace(state.addressSpace),</span><br><span class="line">    constraints(state.constraints),</span><br><span class="line">    pathOS(state.pathOS),</span><br><span class="line">    symPathOS(state.symPathOS),</span><br><span class="line">    coveredLines(state.coveredLines),</span><br><span class="line">    symbolics(state.symbolics),</span><br><span class="line">    arrayNames(state.arrayNames),</span><br><span class="line">    openMergeStack(state.openMergeStack),</span><br><span class="line">    steppedInstructions(state.steppedInstructions),</span><br><span class="line">    instsSinceCovNew(state.instsSinceCovNew),</span><br><span class="line">    unwindingInformation(state.unwindingInformation</span><br><span class="line">                             ? state.unwindingInformation-&gt;clone()</span><br><span class="line">                             : nullptr),</span><br><span class="line">    coveredNew(state.coveredNew),</span><br><span class="line">    forkDisabled(state.forkDisabled) &#123;</span><br><span class="line">  for (const auto &amp;cur_mergehandler: openMergeStack)</span><br><span class="line">    cur_mergehandler-&gt;addOpenState(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>关于state的操作有以下几种，这部分里主要还是merge的逻辑比较复杂。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">branch // 处理分支情况，实际就是复制条件为false的状态</span><br><span class="line">pushFrame </span><br><span class="line">popFrame</span><br><span class="line">addSymbolic</span><br><span class="line">merge //合并状态</span><br><span class="line">dumpStack</span><br><span class="line">addConstraint //调用约束管理器添加约束</span><br></pre></td></tr></table></figure>

<h2 id="5-KLEE内存模型"><a href="#5-KLEE内存模型" class="headerlink" title="5. KLEE内存模型"></a>5. KLEE内存模型</h2><p>klee里还有个很重要的概念就是内存模型。在Memory.h里，我们可以看见有memory object的定义，可以知道memory object有以下属性，包括id，地址，内存对象的大小等等</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">MemoryObject(uint64_t _address, unsigned _size, </span><br><span class="line">             bool _isLocal, bool _isGlobal, bool _isFixed,</span><br><span class="line">             const llvm::Value *_allocSite,</span><br><span class="line">             MemoryManager *_parent)</span><br><span class="line">  : id(counter++),</span><br><span class="line">    address(_address),</span><br><span class="line">    size(_size),</span><br><span class="line">    name(&quot;unnamed&quot;),</span><br><span class="line">    isLocal(_isLocal),</span><br><span class="line">    isGlobal(_isGlobal),</span><br><span class="line">    isFixed(_isFixed),</span><br><span class="line">    isUserSpecified(false),</span><br><span class="line">    parent(_parent), </span><br><span class="line">    allocSite(_allocSite) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而这些内存对象由memory manager来进行管理，在MemoryManager.h里可以看到memory manger负责分配内存、释放内存等等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">  MemoryManager(ArrayCache *arrayCache);</span><br><span class="line">  ~MemoryManager();</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Returns memory object which contains a handle to real virtual process</span><br><span class="line">   * memory.</span><br><span class="line">   */</span><br><span class="line">  MemoryObject *allocate(uint64_t size, bool isLocal, bool isGlobal,</span><br><span class="line">                         const llvm::Value *allocSite, size_t alignment);</span><br><span class="line">  MemoryObject *allocateFixed(uint64_t address, uint64_t size,</span><br><span class="line">                              const llvm::Value *allocSite);</span><br><span class="line">  void deallocate(const MemoryObject *mo);</span><br><span class="line">  void markFreed(MemoryObject *mo);</span><br><span class="line">  ArrayCache *getArrayCache() const &#123; return arrayCache; &#125;</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">   * Returns the size used by deterministic allocation in bytes</span><br><span class="line">   */</span><br><span class="line">  size_t getUsedDeterministicSize();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>前面提到的基于KLEE的工作BovInspector就在Memory.h里建立缓冲区的模型。下面代码就是BovInspector建立的缓冲区的模型。这也告诉我们，如果想要对什么对象建立模型，可以将代码写在Memory.h里。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class BufferObject &#123;</span><br><span class="line">private:</span><br><span class="line">	uint64_t startAddr;</span><br><span class="line">	uint64_t size;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	MemoryObject * mo;</span><br><span class="line">	uint64_t getStartAddr();</span><br><span class="line">	uint64_t getSize();</span><br><span class="line"></span><br><span class="line">	void setStartAddr(uint64_t addr);</span><br><span class="line">	void setSize(unsigned size);</span><br><span class="line">	BufferObject(MemoryObject * mo);</span><br><span class="line">&#125;;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>klee和angr都是符号执行工具，但两者不同的是，angr更像是一个框架，你可以利用框架实现你想要的功能，而klee则是封装比较好的一个工具，可以直接输入命令使用的。另外一个不同点是angr是针对二进制程序操作的，而klee是在LLVM字节码上弄的。</p>
<p>之前对于klee的了解仅仅停留在论文和官方文档，几条命令反复使用。但最近需要修改klee实现想要的功能时，仅仅停留在论文和官方文档就有点不够用了。尝试去看了代码，感觉收益颇丰，看的时候不禁恍然大悟，原来也有我看得懂的地方。</p>
<p>总的来说，klee是基于LLVM的一个很优秀的开源符号执行工具，十几年来都还在更新代码，目前来看功能应该比较完善了，但仍然有可扩展的空间，比如和别的静态分析技术结合，例如SVF(<a target="_blank" rel="noopener" href="https://github.com/SVF-tools/SVF)%E3%80%82">https://github.com/SVF-tools/SVF)。</a></p>
<p>写的比较粗糙，希望大家能从这篇文章有所收获。</p>
<h2 id="7-参考资料"><a href="#7-参考资料" class="headerlink" title="7. 参考资料"></a>7. 参考资料</h2><p>0x1. klee官网：<a target="_blank" rel="noopener" href="http://klee.github.io/">http://klee.github.io/</a></p>
<p>0x2. Cadar C, Dunbar D, Engler D R. Klee: unassisted and automatic generation of high-coverage tests for complex systems programs[C]&#x2F;&#x2F;OSDI. 2008, 8: 209-224.</p>
<p>0x3. klee源码：<a target="_blank" rel="noopener" href="https://github.com/klee/klee">https://github.com/klee/klee</a><br>0x4. BovInspector : <a target="_blank" rel="noopener" href="https://github.com/BovInspectorTool1/project">https://github.com/BovInspectorTool1/project</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/symbolic-execution/" rel="tag"># symbolic execution</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/05/17/%E6%BC%8F%E6%B4%9E%E8%87%AA%E5%8A%A8%E5%88%A9%E7%94%A8AEG%E7%A0%94%E7%A9%B6%E8%BF%9B%E5%B1%95/" rel="prev" title="漏洞自动化利用研究进展">
      <i class="fa fa-chevron-left"></i> 漏洞自动化利用研究进展
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/06/01/BovInspector/" rel="next" title="BovInspector：一个自动化验证缓冲区溢出漏洞的工具">
      BovInspector：一个自动化验证缓冲区溢出漏洞的工具 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#KLEE-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0"><span class="nav-number">1.</span> <span class="nav-text">KLEE 源码阅读笔记</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-klee-%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6"><span class="nav-number">1.2.</span> <span class="nav-text">1. klee 基本框架</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-klee%E4%BB%A3%E7%A0%81%E6%9E%B6%E6%9E%84"><span class="nav-number">1.3.</span> <span class="nav-text">2. klee代码架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-klee%E7%9A%84%E6%89%A7%E8%A1%8C%E5%99%A8Executor"><span class="nav-number">1.4.</span> <span class="nav-text">3. klee的执行器Executor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-klee%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">1.5.</span> <span class="nav-text">4. klee的状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-KLEE%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.6.</span> <span class="nav-text">5. KLEE内存模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E6%80%BB%E7%BB%93"><span class="nav-number">1.7.</span> <span class="nav-text">6. 总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">1.8.</span> <span class="nav-text">7. 参考资料</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="iskindar"
      src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/20220530182402_fa7aa.jpeg">
  <p class="site-author-name" itemprop="name">iskindar</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/iskindar" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;iskindar" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:iskindar97@gmail.com" title="E-Mail → mailto:iskindar97@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">iskindar</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/model/katou_01/katou_01.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>
