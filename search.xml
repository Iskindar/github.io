<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【日语N5】数量词整理</title>
    <url>/2022/05/22/%E3%80%90%E6%97%A5%E8%AF%ADN5%E3%80%91%E6%95%B0%E9%87%8F%E8%AF%8D%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="【日语N5】数量词整理"><a href="#【日语N5】数量词整理" class="headerlink" title="【日语N5】数量词整理"></a>【日语N5】数量词整理</h1><p>数量相关的单词比较烦，所以打算整理下这些词汇，包括1-10，几个，星期几，几月等等的单词。</p>
<table>
<thead>
<tr>
<th>数量</th>
<th>片假名</th>
<th>日期</th>
<th>几个</th>
<th>几人</th>
<th>几分</th>
<th>几时</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>いち</td>
<td>ついたち</td>
<td>ひとつ</td>
<td>ひとり</td>
<td>いっぷん</td>
<td>いちじ</td>
</tr>
<tr>
<td>2</td>
<td>に</td>
<td>ふつか</td>
<td>ふたつ</td>
<td>ふたり</td>
<td>にふん</td>
<td>にじ</td>
</tr>
<tr>
<td>3</td>
<td>さん</td>
<td>みっか</td>
<td>みっつ</td>
<td></td>
<td>さんぷん</td>
<td>さんじ</td>
</tr>
<tr>
<td>4</td>
<td>よん／し</td>
<td>よっか</td>
<td>よっつ</td>
<td>よにん</td>
<td>よんぷん</td>
<td>よんじ</td>
</tr>
<tr>
<td>5</td>
<td>ご</td>
<td>いつか</td>
<td>いつつ</td>
<td></td>
<td>ごふん</td>
<td>ごじ</td>
</tr>
<tr>
<td>6</td>
<td>ろく</td>
<td>むいか</td>
<td>むっつ</td>
<td></td>
<td>ろっぷん</td>
<td>ろくじ</td>
</tr>
<tr>
<td>7</td>
<td>なな　&#x2F;しち</td>
<td>なのか</td>
<td>ななつ</td>
<td></td>
<td>ななふん</td>
<td>しちじ</td>
</tr>
<tr>
<td>8</td>
<td>はち</td>
<td>ようか</td>
<td>やっつ</td>
<td></td>
<td>はっぷん</td>
<td>はちじ</td>
</tr>
<tr>
<td>9</td>
<td>きゅう／く</td>
<td>ここのか</td>
<td>ここのつ</td>
<td></td>
<td>きゅうふん</td>
<td>くじ</td>
</tr>
<tr>
<td>10</td>
<td>じゅう</td>
<td>とおか</td>
<td>とお</td>
<td></td>
<td>じゅっぷん</td>
<td>じゅうじ</td>
</tr>
<tr>
<td></td>
<td>にじゅう</td>
<td>はつか</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>100</td>
<td>ひゃく</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1000</td>
<td>せん</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>10000</td>
<td>まん</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>Japanese</tag>
      </tags>
  </entry>
  <entry>
    <title>【日语学习】N5动词整理</title>
    <url>/2022/05/15/%E3%80%90%E6%97%A5%E8%AF%ADN5%E3%80%91%E5%8A%A8%E8%AF%8D%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="【日语学习】N5动词整理"><a href="#【日语学习】N5动词整理" class="headerlink" title="【日语学习】N5动词整理"></a>【日语学习】N5动词整理</h1><p>最近学て型，有点变不过来，从这个网站（<a href="https://skdesu.com/zh/n5%e5%8a%a8%e8%af%8d%e5%88%97%e8%a1%a8/%EF%BC%89%E4%B8%8A%E6%89%BE%E4%BA%86%E5%8A%A8%E8%AF%8D%E8%A1%A8%EF%BC%8C%E8%87%AA%E5%B7%B1%E5%81%9A%E4%BA%86%E4%B8%80%E9%81%8D%E5%8F%98%E5%BD%A2%E3%80%82%E6%95%B4%E7%90%86%E5%A6%82%E4%B8%8B%E3%80%82%E5%90%8E%E7%BB%AD%E6%9C%89%E6%97%B6%E9%97%B4%E5%86%8D%E8%A1%A5%E5%85%85%E4%BE%8B%E5%8F%A5%EF%BC%8C%E5%8A%A0%E6%B7%B1%E5%AF%B9%E8%BF%99%E4%BA%9B%E5%8A%A8%E8%AF%8D%E7%9A%84%E7%90%86%E8%A7%A3%E3%80%82%E7%8E%B0%E9%98%B6%E6%AE%B5%E5%8F%AA%E6%98%AF%E5%85%88%E7%BB%83%E4%B9%A0%E5%A6%82%E4%BD%95%E5%8F%98%E5%BD%A2%E3%80%82">https://skdesu.com/zh/n5%e5%8a%a8%e8%af%8d%e5%88%97%e8%a1%a8/）上找了动词表，自己做了一遍变形。整理如下。后续有时间再补充例句，加深对这些动词的理解。现阶段只是先练习如何变形。</a></p>
<table>
<thead>
<tr>
<th>动词</th>
<th>片假名</th>
<th>中文</th>
<th>ます</th>
<th>て</th>
</tr>
</thead>
<tbody><tr>
<td>会う</td>
<td>あう</td>
<td>遇见，会面</td>
<td>あいます</td>
<td>あって</td>
</tr>
<tr>
<td>開く</td>
<td>あく</td>
<td>开放（商店、鲜花）</td>
<td>開きます</td>
<td>開いて</td>
</tr>
<tr>
<td>開ける</td>
<td>あける</td>
<td>打开</td>
<td>開けます</td>
<td>あけて</td>
</tr>
<tr>
<td></td>
<td>あげる</td>
<td>给；举起</td>
<td>あげます</td>
<td>あげで</td>
</tr>
<tr>
<td>遊ぶ</td>
<td>あそぶ</td>
<td>玩</td>
<td>遊びます</td>
<td>遊んで</td>
</tr>
<tr>
<td>浴びる</td>
<td>あびる</td>
<td>洗个澡</td>
<td>浴びます</td>
<td>浴びて</td>
</tr>
<tr>
<td>洗う</td>
<td>あらう</td>
<td>洗</td>
<td>洗います</td>
<td>洗って</td>
</tr>
<tr>
<td>有る</td>
<td>ある</td>
<td>存在，存在</td>
<td>あります</td>
<td>有って</td>
</tr>
<tr>
<td>ある</td>
<td>ある</td>
<td>拥有</td>
<td>あります</td>
<td>あって</td>
</tr>
<tr>
<td>歩く</td>
<td>あるく</td>
<td>步行，步行（步行）</td>
<td>歩きます</td>
<td>あるって</td>
</tr>
<tr>
<td>言う</td>
<td>いう</td>
<td>我的意思是说——</td>
<td>いいます</td>
<td>言って</td>
</tr>
<tr>
<td>行く</td>
<td>いく</td>
<td>走</td>
<td>いきます</td>
<td>いって</td>
</tr>
<tr>
<td>入る</td>
<td>いる</td>
<td>进入</td>
<td>いります</td>
<td>いって</td>
</tr>
<tr>
<td>要る</td>
<td>いる</td>
<td>需要</td>
<td>要ります</td>
<td>いって</td>
</tr>
<tr>
<td>居る</td>
<td>いる</td>
<td>存在</td>
<td>居ます</td>
<td>居て</td>
</tr>
<tr>
<td>入れる</td>
<td>いれる</td>
<td>插入，放置，输入</td>
<td>入れます</td>
<td>いれて</td>
</tr>
<tr>
<td>歌う</td>
<td>うたう</td>
<td>唱</td>
<td>歌ます</td>
<td>歌って</td>
</tr>
<tr>
<td>生まれる</td>
<td>うまれる</td>
<td>出生，产生</td>
<td>生まれます</td>
<td>生まれて</td>
</tr>
<tr>
<td>売る</td>
<td>うる</td>
<td>卖</td>
<td>売ります</td>
<td>売って</td>
</tr>
<tr>
<td>起きる</td>
<td>おきる</td>
<td>醒来</td>
<td>起きます</td>
<td>おきまして</td>
</tr>
<tr>
<td>置く</td>
<td>おく</td>
<td>放。搁。置</td>
<td>おきます</td>
<td>置いて</td>
</tr>
<tr>
<td>送る</td>
<td>おくる</td>
<td>提交</td>
<td>送ります。</td>
<td>送って</td>
</tr>
<tr>
<td>押す</td>
<td>おす</td>
<td>推</td>
<td>押します</td>
<td>押して</td>
</tr>
<tr>
<td>覚える</td>
<td>おぼえる</td>
<td>记住，记住</td>
<td>覚えます</td>
<td>覚えて</td>
</tr>
<tr>
<td>泳ぐ</td>
<td>およぐ</td>
<td>游泳</td>
<td>泳ぎます</td>
<td>泳ぎまして</td>
</tr>
<tr>
<td>降りる</td>
<td>おりる</td>
<td>下来（从汽车、楼梯）</td>
<td>降ります</td>
<td>降りて</td>
</tr>
<tr>
<td>終わる</td>
<td>おわる</td>
<td>完成，完成</td>
<td>終わります</td>
<td>終わって</td>
</tr>
<tr>
<td>買う</td>
<td>かう</td>
<td>采购</td>
<td>買います</td>
<td>買って</td>
</tr>
<tr>
<td>返す</td>
<td>かえす</td>
<td>返回（对象）</td>
<td>返します</td>
<td>返して</td>
</tr>
<tr>
<td>帰る</td>
<td>かえる</td>
<td>返回，返回，离开（家）</td>
<td>帰ります</td>
<td>帰って</td>
</tr>
<tr>
<td>掛かる</td>
<td>かかる</td>
<td>垂挂</td>
<td>掛かります</td>
<td>掛かって</td>
</tr>
<tr>
<td>書く</td>
<td>かく</td>
<td>写</td>
<td>書きます</td>
<td>書いて</td>
</tr>
<tr>
<td>掛ける</td>
<td>かける</td>
<td>垂挂</td>
<td>掛けます</td>
<td>掛けて</td>
</tr>
<tr>
<td>掛ける</td>
<td>かける</td>
<td>打个电话</td>
<td>かけます</td>
<td>かけて</td>
</tr>
<tr>
<td>貸す</td>
<td>かす</td>
<td>借</td>
<td>貸します</td>
<td>貸して</td>
</tr>
<tr>
<td>冠る</td>
<td>かぶる</td>
<td>戴在头上（帽子，帽子）</td>
<td>かぶります</td>
<td>かぶって</td>
</tr>
<tr>
<td>借りる</td>
<td>かりる</td>
<td>借</td>
<td>借ります</td>
<td>借りて</td>
</tr>
<tr>
<td>消える</td>
<td>きえる</td>
<td>消失，消失，</td>
<td>消えます</td>
<td>消えて</td>
</tr>
<tr>
<td>聞く</td>
<td>きく</td>
<td>听</td>
<td>聞きます</td>
<td>聞いて</td>
</tr>
<tr>
<td>切る</td>
<td>きる</td>
<td>切</td>
<td>切ります</td>
<td>切って</td>
</tr>
<tr>
<td>着る</td>
<td>きる</td>
<td>穿上，穿上</td>
<td>着ます</td>
<td>着て</td>
</tr>
<tr>
<td>来る</td>
<td>くる</td>
<td>过来</td>
<td>きます</td>
<td>来て</td>
</tr>
<tr>
<td>消す</td>
<td>けす</td>
<td>擦除，关闭，熄灭</td>
<td>消します</td>
<td>消して</td>
</tr>
<tr>
<td>答える</td>
<td>こたえる</td>
<td>回复</td>
<td>答えります</td>
<td>答えて</td>
</tr>
<tr>
<td>困る</td>
<td>こまる</td>
<td>困难，问题</td>
<td>困ります</td>
<td>困って</td>
</tr>
<tr>
<td>咲く</td>
<td>さく</td>
<td>(花)开</td>
<td>咲きます</td>
<td>咲いて</td>
</tr>
<tr>
<td>死ぬ</td>
<td>しぬ</td>
<td>死</td>
<td>死にます</td>
<td>死にまして</td>
</tr>
<tr>
<td>閉まる</td>
<td>しまる</td>
<td>关闭（不及物，godan )</td>
<td>閉まります</td>
<td>閉まって</td>
</tr>
<tr>
<td>閉める</td>
<td>しめる</td>
<td>关闭（传递，ichidan）</td>
<td>閉めます</td>
<td>閉めて</td>
</tr>
<tr>
<td>締める</td>
<td>しめる</td>
<td>勒紧，系紧；束紧；绷紧</td>
<td>しめます</td>
<td>締めて</td>
</tr>
<tr>
<td>知る</td>
<td>しる</td>
<td>知道，知道</td>
<td>知ります</td>
<td>知って</td>
</tr>
<tr>
<td>吸う</td>
<td>すう</td>
<td>呼吸，抽烟</td>
<td>吸います</td>
<td>吸って</td>
</tr>
<tr>
<td>住む</td>
<td>すむ</td>
<td>生活，居住在某个地方</td>
<td>すみます</td>
<td>住んで</td>
</tr>
<tr>
<td>する</td>
<td>する</td>
<td>做</td>
<td>します</td>
<td>して</td>
</tr>
<tr>
<td>座る</td>
<td>すわる</td>
<td>坐</td>
<td>座ります</td>
<td>座って</td>
</tr>
<tr>
<td>出す</td>
<td>だす</td>
<td>接受，给予，放置，展示，发送，展示</td>
<td>出します</td>
<td>出して</td>
</tr>
<tr>
<td>立つ</td>
<td>たつ</td>
<td>起床站起来</td>
<td>立ちます</td>
<td>立って</td>
</tr>
<tr>
<td>頼む</td>
<td>たのむ</td>
<td>问，要求，问</td>
<td>頼みます</td>
<td>頼んで</td>
</tr>
<tr>
<td>食べる</td>
<td>たべる</td>
<td>吃</td>
<td>食べます</td>
<td>食べて</td>
</tr>
<tr>
<td>違う</td>
<td>ちがう</td>
<td>不同，错了，不是吗</td>
<td>違います</td>
<td>違って</td>
</tr>
<tr>
<td>使う</td>
<td>つかう</td>
<td>使用（例如电脑、电话……）</td>
<td>使います</td>
<td>使って</td>
</tr>
<tr>
<td>疲れる</td>
<td>つかれる</td>
<td>筋疲力尽</td>
<td>疲れります</td>
<td>疲れって</td>
</tr>
<tr>
<td>着く</td>
<td>つく</td>
<td>到达</td>
<td>着きます</td>
<td>ついて</td>
</tr>
<tr>
<td>作る</td>
<td>つくる</td>
<td>制造，生产</td>
<td>作ります</td>
<td>作って</td>
</tr>
<tr>
<td>点ける</td>
<td>つける</td>
<td>打开灯，打开，打开</td>
<td>つけます</td>
<td>つけて</td>
</tr>
<tr>
<td>勤める</td>
<td>つとめる</td>
<td>工作，为（某人）服务</td>
<td>勤めります</td>
<td>勤めって</td>
</tr>
<tr>
<td>出かける</td>
<td>でかける</td>
<td>出去</td>
<td>出かけます</td>
<td>出かけて</td>
</tr>
<tr>
<td>出来る</td>
<td>できる</td>
<td>做，能够做某事</td>
<td>出来ます</td>
<td>出来て</td>
</tr>
<tr>
<td>出る</td>
<td>でる</td>
<td>离开</td>
<td>出ます</td>
<td>出まして</td>
</tr>
<tr>
<td>飛ぶ</td>
<td>とぶ</td>
<td>飞</td>
<td>飛びます</td>
<td>飛んで</td>
</tr>
<tr>
<td>止まる</td>
<td>とまる</td>
<td>停</td>
<td>止まります</td>
<td>止まって</td>
</tr>
<tr>
<td>取る</td>
<td>とる</td>
<td>拿，拿</td>
<td>取ります</td>
<td>取って</td>
</tr>
<tr>
<td>撮る</td>
<td>とる</td>
<td>拍照</td>
<td>撮ります</td>
<td>撮って</td>
</tr>
<tr>
<td>鳴く</td>
<td>なく</td>
<td>唱歌、尖叫、喵喵叫（猫）</td>
<td>なきます</td>
<td>鳴いて</td>
</tr>
<tr>
<td>並ぶ</td>
<td>ならぶ</td>
<td>形成一条线</td>
<td>並びます</td>
<td>並んで</td>
</tr>
<tr>
<td>並べる</td>
<td>ならべる</td>
<td>排队</td>
<td>並べます</td>
<td>並べて</td>
</tr>
<tr>
<td></td>
<td>なる</td>
<td>成为</td>
<td>なります</td>
<td>なって</td>
</tr>
<tr>
<td>脱ぐ</td>
<td>ぬぐ</td>
<td>脱衣服，脱衣服</td>
<td>脱ぎます</td>
<td>ぬいで</td>
</tr>
<tr>
<td>寝る</td>
<td>ねる</td>
<td>睡觉睡觉</td>
<td>寝ます</td>
<td>寝て</td>
</tr>
<tr>
<td>登る</td>
<td>のぼる</td>
<td>爬，爬</td>
<td>登ります</td>
<td>登って</td>
</tr>
<tr>
<td>飲む</td>
<td>のむ</td>
<td>喝</td>
<td>飲みます</td>
<td>飲んで</td>
</tr>
<tr>
<td>乗る</td>
<td>のる</td>
<td>骑（自行车，动物）</td>
<td>乗ります</td>
<td>乗って</td>
</tr>
<tr>
<td>入る</td>
<td>はいる</td>
<td>登录</td>
<td>入ります</td>
<td>入って</td>
</tr>
<tr>
<td>履く</td>
<td>はく</td>
<td>穿上（穿上）</td>
<td>はきます</td>
<td>履いて</td>
</tr>
<tr>
<td>始まる</td>
<td>はじまる</td>
<td>开始，开始，开始</td>
<td>始まります</td>
<td>始まって</td>
</tr>
<tr>
<td>走る</td>
<td>はしる</td>
<td>跑</td>
<td>走ります</td>
<td>走って</td>
</tr>
<tr>
<td>働く</td>
<td>はたらく</td>
<td>上班</td>
<td>働きます</td>
<td>働いて</td>
</tr>
<tr>
<td>話す</td>
<td>はなす</td>
<td>说说话说</td>
<td>話します</td>
<td>話して</td>
</tr>
<tr>
<td>張る</td>
<td>はる</td>
<td>拉伸，拉紧，拉紧</td>
<td>はります</td>
<td>張って</td>
</tr>
<tr>
<td>晴れる</td>
<td>はれる</td>
<td>干净清澈、放晴</td>
<td>晴れます</td>
<td>晴れて</td>
</tr>
<tr>
<td>引く</td>
<td>ひく</td>
<td>拉, 拉 (eng: 拉)</td>
<td>引きます</td>
<td>引いて</td>
</tr>
<tr>
<td>弾く</td>
<td>ひく</td>
<td>演奏乐器</td>
<td>弾きます</td>
<td>弾いて</td>
</tr>
<tr>
<td>吹く</td>
<td>ふく</td>
<td>吹</td>
<td>吹きます</td>
<td>吹いて</td>
</tr>
<tr>
<td>降る</td>
<td>ふる</td>
<td>落下（雨、雪）</td>
<td>降ります</td>
<td>降って</td>
</tr>
<tr>
<td>曲がる</td>
<td>まがる</td>
<td>转弯，弯曲，扭曲</td>
<td>曲がります</td>
<td>曲がって</td>
</tr>
<tr>
<td>待つ</td>
<td>まつ</td>
<td>等待</td>
<td>待ちます</td>
<td>待って</td>
</tr>
<tr>
<td>磨く</td>
<td>みがく</td>
<td>刷，抛光</td>
<td>磨きます</td>
<td>磨いて</td>
</tr>
<tr>
<td>見せる</td>
<td>みせる</td>
<td>显示</td>
<td>見せます</td>
<td>見せて</td>
</tr>
<tr>
<td>見る</td>
<td>みる</td>
<td>看，看，看</td>
<td>見ます</td>
<td>見まして</td>
</tr>
<tr>
<td>持つ</td>
<td>もつ</td>
<td>拥有</td>
<td>持ちます</td>
<td>持って</td>
</tr>
<tr>
<td>休む</td>
<td>やすむ</td>
<td>休息</td>
<td>休みます</td>
<td>休んで</td>
</tr>
<tr>
<td></td>
<td>やる</td>
<td>做</td>
<td>やります</td>
<td>やって</td>
</tr>
<tr>
<td>呼ぶ</td>
<td>よぶ</td>
<td>打电话</td>
<td>呼びます</td>
<td>呼んで</td>
</tr>
<tr>
<td>読む</td>
<td>よむ</td>
<td>读</td>
<td>読みます</td>
<td>読んで</td>
</tr>
<tr>
<td>分かる</td>
<td>わかる</td>
<td>明白，知道</td>
<td>わかります</td>
<td>分かって</td>
</tr>
<tr>
<td>忘れる</td>
<td>わすれる</td>
<td>忘记</td>
<td>忘れます</td>
<td>忘れて</td>
</tr>
<tr>
<td>渡す</td>
<td>わたす</td>
<td>交付（礼物……）</td>
<td>渡します</td>
<td>渡して</td>
</tr>
<tr>
<td>渡る</td>
<td>わたる</td>
<td>交叉，继续前进</td>
<td>わたります</td>
<td>渡って</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>Japanese</tag>
      </tags>
  </entry>
  <entry>
    <title>【日语N5】名词整理</title>
    <url>/2022/05/22/%E3%80%90%E6%97%A5%E8%AF%ADN5%E3%80%91%E5%90%8D%E8%AF%8D%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="【日语N5】名词整理"><a href="#【日语N5】名词整理" class="headerlink" title="【日语N5】名词整理"></a>【日语N5】名词整理</h1><p>学了一段时间日语，前面的一些单词记不住了。于是打算按用途整理一下名词。</p>
]]></content>
      <tags>
        <tag>Japanese</tag>
      </tags>
  </entry>
  <entry>
    <title>【日语N5】语法整理</title>
    <url>/2022/04/17/%E3%80%90%E6%97%A5%E8%AF%ADN5%E3%80%91%E8%AF%AD%E6%B3%95%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>学日语有两个多月了，回顾下这两个月的比较重要的语法（或者说我比较容易忘的），记录于此。</p>
<span id="more"></span>



<h2 id="输入法相关"><a href="#输入法相关" class="headerlink" title="输入法相关"></a>输入法相关</h2><p>片假名长音 ー：按键盘上的“-”</p>
<blockquote>
<p>ビール　bi-ru</p>
</blockquote>
<p>促音 っ：双写后面假名的首字母</p>
<blockquote>
<p>ちょっと　cyotto</p>
<p>かった　kadda</p>
</blockquote>
<p>小写假名：x+假名读音</p>
<blockquote>
<p>ティアーズ　te<strong>x</strong>ia-zu</p>
</blockquote>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/44804518">https://zhuanlan.zhihu.com/p/44804518</a></p>
<h2 id="形容词"><a href="#形容词" class="headerlink" title="形容词"></a>形容词</h2><p>形容词分为两类：</p>
<ul>
<li>1类形容词，以い结尾的　楽しい  いい　優しい　たかい　早い</li>
<li>2类形容词，不以い结尾的：きれい　静か　簡単</li>
</ul>
<table>
<thead>
<tr>
<th>时态</th>
<th>1类</th>
<th>2类</th>
</tr>
</thead>
<tbody><tr>
<td>肯定（现在）</td>
<td>楽しい　楽しい<strong>です</strong></td>
<td>きれい<strong>だ</strong>　きれい<strong>です</strong></td>
</tr>
<tr>
<td>否定（现在）</td>
<td>楽し<strong>くない</strong></td>
<td>きれい<strong>じゃない</strong>　きれい<strong>ではないです</strong>　きれい<strong>ではありません</strong>　きれい<strong>じゃありません</strong></td>
</tr>
<tr>
<td>肯定（过去）</td>
<td>楽し<strong>かった</strong></td>
<td>きれい<strong>だった</strong>　きれい<strong>でした</strong></td>
</tr>
<tr>
<td>否定（过去）</td>
<td>楽し<strong>くなかっだ</strong></td>
<td>きれい<strong>じゃなかった</strong>　きれい<strong>ではなかっだ</strong>　きれい<strong>ではありませんでした</strong>　きれい<strong>じゃありませんでした</strong></td>
</tr>
<tr>
<td>修饰名词时</td>
<td>楽しい旅行</td>
<td>綺麗<strong>な</strong>写真</td>
</tr>
</tbody></table>
<p>1类形容词中有个特殊的变形是 いい，他的变形方式如下：</p>
<ul>
<li>肯定（现在）：いいです</li>
<li>否定（现在）：よくない</li>
<li>肯定（过去）：<strong>よかった</strong></li>
<li>否定（过去）：よくなかった</li>
</ul>
<p>和形容词相关的疑问句有下面两种，主要是询问怎么样（how）：</p>
<ul>
<li>どうですか<ul>
<li>日本の地下鉄はどうですか？便利です</li>
</ul>
</li>
<li>どんな＋名词<ul>
<li>大阪はどんなまちですか？賑やかな町です</li>
</ul>
</li>
</ul>
<p>1类形容词把い 改成く，可变为副词，去修饰动词，比如：</p>
<ul>
<li><p>早<strong>く</strong>帰る</p>
</li>
<li><p>英語が　よ<strong>く</strong>　わかります</p>
</li>
</ul>
<h2 id="动词"><a href="#动词" class="headerlink" title="动词"></a>动词</h2><h2 id="助词"><a href="#助词" class="headerlink" title="助词"></a>助词</h2><h2 id="疑问词的整理"><a href="#疑问词的整理" class="headerlink" title="疑问词的整理"></a>疑问词的整理</h2><p>在做课后练习的时候，有时候总被疑问词搞得晕头转向，于是整理如下。可能按照具体的用途来分类会更好些。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/%E7%96%91%E9%97%AE%E8%AF%8D.png" alt="疑问词"></p>
<h3 id="数字相关"><a href="#数字相关" class="headerlink" title="数字相关"></a>数字相关</h3><p><a href="https://zhuanlan.zhihu.com/p/360670644">https://zhuanlan.zhihu.com/p/360670644</a></p>
]]></content>
      <tags>
        <tag>Japanese</tag>
      </tags>
  </entry>
  <entry>
    <title>BovInspector：一个自动化验证缓冲区溢出漏洞的工具</title>
    <url>/2021/06/01/BovInspector/</url>
    <content><![CDATA[<h1 id="BovInspector：一个自动化验证缓冲区溢出漏洞的工具"><a href="#BovInspector：一个自动化验证缓冲区溢出漏洞的工具" class="headerlink" title="BovInspector：一个自动化验证缓冲区溢出漏洞的工具"></a>BovInspector：一个自动化验证缓冲区溢出漏洞的工具</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>静态分析工具可以很全面地检测软件，但是误报率也很高。人工地去验证这些静态分析报告是费时费力的过程。BovInspector可以去自动化地验证静态分析找出的缓冲区溢出漏洞。本文将介绍BovInspector的基本原理，安装使用方法。</p>
<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>BovInspector来源于2020年期刊 Journal of Computer Science and Technology的一篇文章《Automatic Buffer Overflow Warning Validation》，最早是16年软工A类会议ASE上的一篇short paper。</p>
<p>该工具主要是基于KLEE，实现了一个自动验证静态分析报告的工具。换个角度看，也有点像利用静态分析来减少符号执行的路径爆炸问题的工作。</p>
<h2 id="2-原理"><a href="#2-原理" class="headerlink" title="2.原理"></a>2.原理</h2><p>工具的基本框架如下图所示（下图来源于论文）。主要工作有以下3点：</p>
<p>a. Warning Reachability Analysis（基于LLVM的PASS实现）</p>
<p>b.Guided Symbolic Execution（基于KLEE实现）</p>
<p>c. Targeted Automatic Repair Suggestions（Python脚本）</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20210503112111595.png" alt="image-20210503112111595"></p>
<p>下面将主要对Warning Reachability Analysis和Guided Symbolic Execution做重点介绍，并简单介绍自动修补。</p>
<h3 id="2-1-Warning-Reachability-Analysis"><a href="#2-1-Warning-Reachability-Analysis" class="headerlink" title="2.1 Warning Reachability Analysis"></a>2.1 Warning Reachability Analysis</h3><p>这部分工作主要是确认静态分析找出的缓冲区溢出是否存在一条路径到达程序入口。首先，这部分内容的输入主要有两个，一个是源码，一个是buffer overflow warning。</p>
<p>buffer overflow warning用一个三元组表示(d,[l1,l2,…,ln],o)​，其中<em>d</em>表示buf定义的行号，l1,l2,…,ln表示对buf操作的行号，o表示溢出点。</p>
<p>由于静态分析工具检测的漏洞有可能在路径上是不可达的，因此，作者打算先过滤掉从程序入口到达不了的漏洞警告。具体来说，作者写了一个llvm pass先构建控制流图，再基于调用关系构建过程间的控制流图。然后在过程间的控制流图上，从漏洞点出发，往上追溯buf操作的语句，如果能够追溯到程序入口，说明这个漏洞有可能被触发。</p>
<p>这部分源码主要包含以下组件，核心是buildCFG.cpp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|-- CFGWriter.h //打印CFG</span><br><span class="line">|-- ReverseSearchPath.cpp//逆向搜索路径</span><br><span class="line">|-- ReverseSearchPath.h</span><br><span class="line">|-- buildCFG.cpp //warning reachability analysis的核心</span><br><span class="line">|-- convinent.cpp//包含一些方便的函数，比如获取行号，获取源文件名等等</span><br><span class="line">|-- convinent.h</span><br><span class="line">|-- mylib</span><br><span class="line">|   `-- printSTL.h</span><br><span class="line">|-- programCFG.cpp//构建过程间控制流图</span><br><span class="line">|-- programCFG.h</span><br><span class="line">|-- targetPosition.cpp//将缓冲区溢出警告里的行号映射为基本块</span><br><span class="line">`-- targetPosition.h</span><br></pre></td></tr></table></figure>

<p>下面这段是buildCFG.cpp的主要代码，首先构建过程间控制流图（line 4）。</p>
<p>然后基于buffer overflow warning的信息，去获取buf定义、操作、溢出的行号在哪些基本块里（line 5-7）。也就是targetPosition.cpp里的逻辑。</p>
<p>接着从溢出点的基本块和离溢出最近的一个buf操作的基本块开始，搜索这两个基本块的路径（ReverseSearchPath.cpp），直到遍历完所有的target point。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">buildCFG::doInitialization</span><span class="params">(Module &amp;M)</span>&#123; </span><br><span class="line"></span><br><span class="line">	errs()&lt;&lt;<span class="string">&quot;build programCFG-------------------------------------------------------------------\n&quot;</span>;</span><br><span class="line">	new ProgramCFG(M);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;BasicBlock*,BasicBlock*&gt; &gt; *target_point=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span>(!targetListFileName.empty())</span><br><span class="line">		target_point=getTargetPoint(targetListFileName,M);</span><br><span class="line">	errs()&lt;&lt;target_point-&gt;size()&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span>(target_point-&gt;size()!=<span class="number">0</span>)&#123;</span><br><span class="line">		errs()&lt;&lt;<span class="string">&quot;the path number is  &quot;</span>&lt;&lt;target_point-&gt;size()&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i=<span class="number">0</span>;i&lt;target_point-&gt;size();i++)&#123;</span><br><span class="line">			Function *main = M.getFunction(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">			SearchReversePaths(target_point-&gt;at(i).first,target_point-&gt;at(i).second,&amp;main-&gt;getEntryBlock(),M,i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> errs()&lt;&lt;<span class="string">&quot;No valid path in checklist!!&quot;</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-Guided-Symbolic-Execution"><a href="#2-2-Guided-Symbolic-Execution" class="headerlink" title="2.2 Guided Symbolic Execution"></a>2.2 Guided Symbolic Execution</h3><p>指导符号执行的目的是验证缓冲区溢出漏洞是否可以被触发。整个流程大致如下图所示。首先，从执行状态池里选择一个状态。接着，执行指令，如果执行到漏洞点，调用验证模块，检测一下当前的状态是否满足漏洞的约束条件，如果满足，则说明是漏洞，反之则是误报。如果执行到分支指令，就复制当前状态，同时筛选状态。最后就是更新状态。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20210503190438707.png" alt="image-20210503190438707"></p>
<p>筛选状态的算法如下图所示，图来源于论文。es，es2分别表示分支为true的状态和分支为false状态。因此，l1，l2分别表示es，es2状态的将要执行的下一条指令的行号。如果之前提取的warning路径集合里包含l1或l2，则筛选掉另外一个。但如果路径集合里没有l1，l2，或者都有l1，l2，就不做筛选操作。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20210503190756936.png" alt="image-20210503190756936"></p>
<p>不筛选的原因有两个。第一，路径集合里没有l1，l2，有可能是符号执行去探索一些没有出现在警告路径里的库函数调用。第二，路径集合里有l1和l2，可能是溢出点在循环里，这样两个分支就都存在warning路径。</p>
<p>漏洞验证模块是去求解当前状态是否满足人工设定的漏洞约束条件。设定的约束条件如下表所示（表来源于论文）。这部分代码可以查看project&#x2F;src&#x2F;klee_symbolic_execution&#x2F;lib&#x2F;Core&#x2F;Executor.cpp里的BFO_Check函数。代码量比较大，大概2000行左右，就不贴出来了。主要思路就是根据各种容易出问题的库函数API，设定缓冲区溢出的约束条件。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20210503193633408.png" alt="image-20210503193633408"></p>
<h3 id="2-3-Targeted-Automatic-Repair-Suggestions"><a href="#2-3-Targeted-Automatic-Repair-Suggestions" class="headerlink" title="2.3 Targeted Automatic Repair Suggestions"></a>2.3 Targeted Automatic Repair Suggestions</h3><p>BovInspector修补漏洞的策略采用专家知识构建的模板，主要有以下11种修补模式（表源于论文）。具体实现可以去看代码（位于project&#x2F;src&#x2F;repair_buffer_overflow&#x2F;repair.py ）</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20210503192324877.png" alt="image-20210503192324877"></p>
<h2 id="3-安装"><a href="#3-安装" class="headerlink" title="3.安装"></a>3.安装</h2><p>想跳过下面的安装步骤，可以直接用我构建好的docker 镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull iskindar/bov:v1</span><br><span class="line">docker run -ti --ulimit=&#x27;stack=-1:-1&#x27; --name=&quot;bovinspector&quot; iskindar/bov:v1</span><br><span class="line">source /etc/profile #加载环境变量</span><br></pre></td></tr></table></figure>

<h3 id="3-1-源码安装"><a href="#3-1-源码安装" class="headerlink" title="3.1 源码安装"></a>3.1 源码安装</h3><p>这里提供了docker的安装方式，因为原工具的开发时间比较早，一些环境比较老旧，用docker方便一点。</p>
<p>构建docker镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -ti --ulimit=&#x27;stack=-1:-1&#x27; --name=&quot;bovinspector&quot; ubuntu:14.04</span><br></pre></td></tr></table></figure>

<p>进入docker容器安装依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ apt-get update</span><br><span class="line">$ apt-get install g++ python curl cmake git bison flex bc libcap-dev</span><br><span class="line">$ apt-get install zlib1g-dev</span><br></pre></td></tr></table></figure>

<p>安装llvm-gcc</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ wget http://llvm.org/releases/2.9/llvm-gcc4.2-2.9-x86_64-linux.tar.bz2</span><br><span class="line">$ tar -jxvf llvm-gcc4.2-2.9-x86_64-linux.tar.bz2</span><br></pre></td></tr></table></figure>

<p>将llvm-gcc添加到环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim /etc/profile</span></span><br><span class="line">export PATH=$PATH:/root/llvm-gcc4.2-2.9-x86_64-linux/bin #把这行加入/etc/profile文件末尾</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">source</span> /etc/profile</span></span><br></pre></td></tr></table></figure>

<p>源码安装llvm-2.9，安好之后，可以把按上面的步骤把llvm-2.9&#x2F;Release+Asserts&#x2F;bin加入环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ wget http://llvm.org/releases/2.9/llvm-2.9.tgz</span><br><span class="line">$ tar -zxvf llvm-2.9.tgz  </span><br><span class="line">$ cd llvm-2.9  </span><br><span class="line">$ ./configure --enable-optimized --enable-assertions  </span><br><span class="line">$ make</span><br></pre></td></tr></table></figure>

<p>安装minisat（STP需要这个）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/stp/minisat.git</span><br><span class="line">$ cd minisat</span><br><span class="line">$ mkdir build</span><br><span class="line">$ cd build</span><br><span class="line">$ cmake ../</span><br><span class="line">$ make</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure>

<p>安装STP(约束求解器)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ tar xzfv 2.1.0.tar.gz  </span><br><span class="line">$ cd stp-2.1.0</span><br><span class="line">$ mkdir build</span><br><span class="line">$ cd build</span><br><span class="line">$ cmake ..  </span><br><span class="line">$ make</span><br><span class="line">$ sudo make DESTDIR=/root/stp_install install</span><br></pre></td></tr></table></figure>

<p>安装uclibc（KLEE用来模拟库函数的组件）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone git://github.com/klee/klee-uclibc.git</span><br><span class="line">$ cd klee-uclibc</span><br><span class="line">$ ./configure --make-llvm-lib</span><br><span class="line">$ make -j2</span><br><span class="line">$ cd ..</span><br></pre></td></tr></table></figure>

<p>安装bovinspector，为方便使用，也可以把project&#x2F;src&#x2F;klee_symbolic_execution&#x2F;Release+Asserts&#x2F;bin加入环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/BovInspectorTool1/project.git</span><br><span class="line">cd project/src/klee_symbolic_execution/</span><br><span class="line">./configure --with-llvm=/root/llvm-2.9 --with-stp=/root/stp_install --with-uclibc=/root/klee-uclibc --enable-posix-runtime</span><br><span class="line">make -j $(grep -c processor /proc/cpuinfo) ENABLE_OPTIMIZED=1</span><br></pre></td></tr></table></figure>

<p>安装llvm pass</p>
<p>将project&#x2F;src&#x2F;build_control_flow_graph移到llvm-2.9&#x2F;lib&#x2F;Transform&#x2F;下，并将文件夹重命名为buildCFG</p>
<p>修改lib&#x2F;Transform&#x2F;Makefile为(就是第二行加个buildCFG：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LEVEL = ../..</span><br><span class="line">PARALLEL_DIRS = Utils Instrumentation Scalar InstCombine IPO Hello BuildCFG</span><br><span class="line"></span><br><span class="line">include $(LEVEL)/Makefile.config</span><br><span class="line"></span><br><span class="line"># No support for plugins on windows targets</span><br><span class="line">ifeq ($(HOST_OS), $(filter $(HOST_OS), Cygwin MingW Minix))</span><br><span class="line">  PARALLEL_DIRS := $(filter-out Hello, $(PARALLEL_DIRS))</span><br><span class="line">  PARALLEL_DIRS := $(filter-out buildcfg, $(PARALLEL_DIRS))</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">include $(LEVEL)/Makefile.common</span><br></pre></td></tr></table></figure>

<p>回到llvm-2.9&#x2F;目录下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./configure --enable-optimized --enable-assertions  </span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p>可以看到&#x2F;root&#x2F;llvm-2.9&#x2F;Release+Asserts&#x2F;lib目录下有buildCFG.so，就说明安装成功了。</p>
<h2 id="4-使用"><a href="#4-使用" class="headerlink" title="4. 使用"></a>4. 使用</h2><p>论文中给的一个简单的测试程序src.c：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_LEN  24</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_LEN  4</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">usage</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> des_buffer[MIN_LEN];  </span><br><span class="line">    <span class="type">char</span>* src_buffer=<span class="string">&quot;this is an example&quot;</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(des_buffer,src_buffer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">initialize</span><span class="params">(<span class="type">char</span>* argv_string)</span> &#123;</span><br><span class="line">    <span class="type">char</span> mapped_argv[MIN_LEN];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(argv_string) &gt;= MAX_LEN)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(mapped_argv,argv_string);</span><br><span class="line">    <span class="keyword">if</span> (argv_string[<span class="number">0</span>] != <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">strcat</span>(mapped_argv, <span class="string">&quot;-&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MAX_LEN;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;	</span><br><span class="line">    <span class="type">char</span>* mode = (<span class="type">char</span>*)<span class="built_in">malloc</span>(MIN_LEN);</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(argv[<span class="number">1</span>]) &lt; MIN_LEN)</span><br><span class="line">        len = initialize(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        mode = (<span class="type">char</span>*)<span class="built_in">realloc</span>(mode, len);</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        mode[<span class="number">0</span>] = argv[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    mode[MIN_LEN<span class="number">-1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">free</span>(mode);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设用某些静态分析工具跑出的结果checklist_bufferoverflow：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">src.c	7	DEF</span><br><span class="line">src.c	9	BOF</span><br><span class="line">END_PATH</span><br><span class="line">1</span><br><span class="line">src.c	22	DEF</span><br><span class="line">src.c	26	N/A</span><br><span class="line">src.c	12	N/A</span><br><span class="line">src.c	15	N/A</span><br><span class="line">src.c	17	BOF</span><br><span class="line">END_PATH</span><br><span class="line">2</span><br><span class="line">src.c	28	DEF</span><br><span class="line">src.c	33	BOF</span><br><span class="line">END_PATH</span><br><span class="line">3</span><br><span class="line">src.c	22	DEF</span><br><span class="line">src.c	26	N/A</span><br><span class="line">src.c	12	N/A</span><br><span class="line">src.c	15	BOF</span><br><span class="line">END_PATH</span><br></pre></td></tr></table></figure>

<p>新建一个文件夹，比如paper_example</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir paper_example</span><br><span class="line">vim src.c # 将上面的内容复制进来</span><br><span class="line">vim checklist_bufferoverflow #将上面的内容复制进来</span><br></pre></td></tr></table></figure>

<p>用llvm-gcc生成字节码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">llvm-gcc --emit-llvm -c -g src.c</span><br></pre></td></tr></table></figure>

<p>构建CFG，生成GuideSrc.txt，programCFG.dot</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">opt -load /root/llvm-2.9/Release+Asserts/lib/buildCFG.so -buildCFG -targetList=./checklist_bufferoverflow src.o</span><br></pre></td></tr></table></figure>

<p>运行klee，验证warning</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">klee --libc=uclibc --posix-runtime --guided-execution src.o --sym-args 1 3 25</span><br></pre></td></tr></table></figure>

<p>最后应该会生成report_BFO.txt和report_NOTBFO.txt文件，内容如下：</p>
<p>report_BFO.txt：真实的缓冲区溢出所在行数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src.c_17 strcat</span><br></pre></td></tr></table></figure>

<p>report_NOTBFO.txt：误报的缓冲区溢出漏洞行数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src.c_15 strcpy</span><br></pre></td></tr></table></figure>

<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>最后简单总结下，这个工具的思路虽然很简单，但实际实现过程的代码量还是相当大的。另外，可能因为这个工作比较早完成的，一些软件的版本比较老，让我安装起来着实费了不少劲。非常感谢这篇论文作者将工作开源了，让本菜鸡能够学习到如何去修改KLEE实现相应的功能，并加深了对于KLEE工作的理解。</p>
<h2 id="6-参考"><a href="#6-参考" class="headerlink" title="6. 参考"></a>6. 参考</h2><ol>
<li>Gao F, Wang L, Li X. BovInspector: Automatic inspection and repair of buffer overflow vulnerabilities. In Proc. the 31st IEEE&#x2F;ACM Int. Conference on Automated Software Engineering, Sept. 2016, pp.786-791.</li>
<li>bovinspector：<a href="https://github.com/BovInspectorTool1/project">https://github.com/BovInspectorTool1/project</a></li>
<li>bovinspector项目介绍：<a href="https://bovinspectortool1.github.io/project/">https://bovinspectortool1.github.io/project/</a></li>
</ol>
]]></content>
      <tags>
        <tag>symbolic execution</tag>
      </tags>
  </entry>
  <entry>
    <title>【论文笔记】Effective Seed Scheduling for Fuzzing with Graph Centrality Analysis</title>
    <url>/2022/10/10/Effective%20Seed%20Scheduling%20for%20Fuzzing%20with%20Graph%20Centrality%20Analysis/</url>
    <content><![CDATA[<h1 id="Effective-Seed-Scheduling-for-Fuzzing-with-Graph-Centrality-Analysis"><a href="#Effective-Seed-Scheduling-for-Fuzzing-with-Graph-Centrality-Analysis" class="headerlink" title="Effective Seed Scheduling for Fuzzing with Graph Centrality Analysis"></a>Effective Seed Scheduling for Fuzzing with Graph Centrality Analysis</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>种子调度，用来确定种子选择的顺序，很大影响了fuzzer的性能。现有的方法利用历史变异信息来调度，但是忽视了控制流图的结构。检查CFG可以帮助种子调度从变异种子上提高边的覆盖率。</p>
<p>一个理想的策略是基于种子通过突变产生的所有可达和可行边的数量来调度种子。但是计算所有边的可达性的开销很大。因此，种子调度策略需要估计这个数量。作者发现估计的count需要满足三个属性：</p>
<ul>
<li><p>当一个种子可以到达更多的边的时候，count需要增加</p>
</li>
<li><p>当一个历史变异信息提示边很难到达的时候或者边离当前访问的边很远的时候，count需要减少</p>
</li>
<li><p>需要在大型CFG中进行计算。</p>
</li>
</ul>
<p>作者观察到图分析里的中心性提供了这三个属性，因此可以高效地估计到达未访问边的概率。然后，构建一种名为edge horizon 的图，能够连接种子到他们最近的未访问节点，然后计算种子的中心性去测量变异一个种子的边覆盖率增量（gain）。</p>
<p>作者实现了他们的方法，叫做K-Scheduler，并且和其他著名的种子调度策略比较。发现K-Scheduler在12个谷歌的fuzzbench上，相比Entropic提高了25.89%的特征覆盖率，比next-best AFL-Based调度器的边覆盖率要高4.21%。同样也发现了3个未知的漏洞。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>给定目标程序，种子语料库和程序的过程间控制流图。基于控制流图先生成edge horizon graph。这个图只包含种子，horizon和non-horizon未访问的节点。然后对edge horizon graph计算Katz中心性。然后fuzzer会优先变异更高中心性的种子。后续fuzzer访问到了这些之前没访问过的节点后，就删除这些新访问的节点，然后重新在更新后的edge horizon graph上计算Katz 中心性。</p>
<p>图a是最左边小程序的控制流图。图b是edge horizon graph。节点A和B是horizon node，因为他们是未访问的节点，且他们的父节点是访问过的。然后把种子节点插入到CFG中，然后将他们与horizon node相连。与之相连的horizon node的父节点需要在种子的执行路径上。所以a&#x3D;5，b&#x3D;30这一种子只与A节点相连。最后删除掉所有已访问过的节点。<img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20221011155104202.png" alt="image-20221011155104202"></p>
<p>katz中心性计算如下：使用β来表示通过变异到达一个节点的难易程度。例如，在100次变异过程中，70次到达了horizon node A的父节点，30次到达了horizon node B的父节点，所以A的β值为1-0.7&#x3D;0.3，B的值为0.7。这说明节点A更难到达。Katz中心性也会随着节点越远而减少。中心性的计算采取迭代的方式计算，最终会收敛。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20221011160600975.png" alt="image-20221011160600975"></p>
<p>论文中还介绍了如何构造Edge horizon graph，如何计算Katz 中心性以及实际是如何应用到fuzz中的。对这部分内容感兴趣的可以去看原文。本文就不再赘述了。</p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>结果部分主要回答以下五个问题：</p>
<ol>
<li>和其他的调度策略相比如何？</li>
<li>能否提高fuzzer发现漏洞的能力</li>
<li>运行时的开销如何？</li>
<li>K-Scheduler的各种设计选择会如何影响他的性能</li>
<li>能否应用到非进化算法的模糊测试中？</li>
</ol>
<h3 id="问题1：和其他的调度策略相比如何？"><a href="#问题1：和其他的调度策略相比如何？" class="headerlink" title="问题1：和其他的调度策略相比如何？"></a>问题1：和其他的调度策略相比如何？</h3><p>第一个表是跑1小时，第二个表是跑24小时。整体上的覆盖率都是高的。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20221011171634569.png" alt="image-20221011171634569"></p>
<p>作者认为他们的工作能在前期有个比较好的提升。随着时间的增加，entropic也会分配能量到那些好的种子上去，从而就缩小了差距。</p>
<p>对比AFL上实现的工作，感觉在1h增加的覆盖率更高一些。AFL上增加的幅度实际上不是很大。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20221011172559280.png" alt="image-20221011172559280"></p>
<h3 id="问题2：能否提高fuzzer发现漏洞的能力"><a href="#问题2：能否提高fuzzer发现漏洞的能力" class="headerlink" title="问题2：能否提高fuzzer发现漏洞的能力"></a>问题2：能否提高fuzzer发现漏洞的能力</h3><p>能比最好的多找3个。作者计算漏洞的数量是先用AFL-Cmin去减少崩溃输入的数量。然后通过stack traces进一步过滤。最后追踪剩下的崩溃输入，并且人工检查他们的stack traces和源码。</p>
<p><img src="C:\Users\zhang\AppData\Roaming\Typora\typora-user-images\image-20221011173051707.png" alt="image-20221011173051707"></p>
<h3 id="3-运行开销"><a href="#3-运行开销" class="headerlink" title="3. 运行开销"></a>3. 运行开销</h3><p>运行开销主要分为</p>
<ul>
<li>fuzzer记录边命中的数量和计算种子能量</li>
<li>调用K-Scheduler来调度种子</li>
</ul>
<p>运行开销不大，看起来可以忽略不计。开销和程序CFG节点的数量有关。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20221011173756162.png" alt="image-20221011173756162"></p>
<h3 id="4-哪些参数会影响"><a href="#4-哪些参数会影响" class="headerlink" title="4. 哪些参数会影响"></a>4. 哪些参数会影响</h3><p>1）中心性算法：对比了PageRank，Eigenvector,Degree,Katz这几种</p>
<p>2）Katz的β，α参数的影响。（有点像调参出来的）</p>
<p>3）删除已访问的节点：虽然文章没说原因，感觉是减少了运行开销，所以最后的覆盖率增加了。</p>
<p>4）Loop removal：引入了loop removal transform来缓解循环对中心性计算的影响。</p>
<h3 id="5-应用到QSYM上"><a href="#5-应用到QSYM上" class="headerlink" title="5. 应用到QSYM上"></a>5. 应用到QSYM上</h3><p>作者把k-scheduler整合进QSYM中，发现也提高了不少覆盖率。但是实验结果还比较初步，准备留到未来再详细讨论。</p>
<h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>相关工作部分主要讲了图中心性和种子调度这两方面。</p>
<h3 id="图中心性"><a href="#图中心性" class="headerlink" title="图中心性"></a>图中心性</h3><p>图中心性列举了不少指标，包括degree centrality, semi-local centrality, closeness centrality, betweenness centrality, eigenvector centrality, katz centrality, PageRank。这些中心性指标已经被应用到各种领域，比如社交网络分析，生物，经济和地理等等。作者认为他们是第一个用在fuzzing的种子选择里。</p>
<h3 id="种子调度"><a href="#种子调度" class="headerlink" title="种子调度"></a>种子调度</h3><p>种子调度包含两部分主要模块：种子选择和能量调度。</p>
<p>前人工作在选择种子上，有利用边和路径覆盖率的，也有用一些安全敏感的指标，比如执行时间，可利用性，内存访问或者他们的组合。另一类选择种子的工作是基于调用图。而作者的工作是基于完整的过程间的控制流图。AFLGo也基于完整的过程间控制流图，不过他计算的是距离，并且用来作定向模糊测试。而本文侧重的是增加覆盖率。SAVIOR也估计这个分数，不过是用在bug-driven的混合测试里。他的假设是所有的边都是同等可到达的，也不管种子执行路径的距离。这个假设和真实程序的场景不太吻合。不管哪个，都用了变异的历史信息来优化这个估计过程。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>文章提出的horizon node graph的图很有意思。并且katz中心性是可以根据fuzzer状态动态更新的。这点或许可以借鉴。</p>
<p>实验部分也做得好扎实，足足有7页，再加上一大堆图表。就是对benchmark程序的选择有些疑惑。没明白为什么选这些程序。虽然提到了未来要测试所有的程序。</p>
<p>开源于：<a href="https://github.com/Dongdongshe/K-Scheduler">https://github.com/Dongdongshe/K-Scheduler</a></p>
]]></content>
      <tags>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title>【论文笔记】LibAFL, A Framework to Build Modular and Reusable Fuzzers</title>
    <url>/2022/08/30/LibAFL-%20A%20Framework%20to%20Build%20Modular%20and%20Reusable%20/</url>
    <content><![CDATA[<h1 id="LibAFL-A-Framework-to-Build-Modular-and-Reusable-Fuzzers"><a href="#LibAFL-A-Framework-to-Build-Modular-and-Reusable-Fuzzers" class="headerlink" title="LibAFL: A Framework to Build Modular and Reusable Fuzzers"></a>LibAFL: A Framework to Build Modular and Reusable Fuzzers</h1><p>简介：</p>
<p>AFL是软件安全测试领域的一个重要里程碑，使得fuzzing成为了一个主要的研究领域，并带动了大量的研究去提高fuzzing流水线上的各个方面。</p>
<p>许多研究是通过fork AFL的代码来进行实现的。虽然一开始看起来挺合适的，但是要把多种fork合并到一个fuzzer，需要大量的工程开销，阻碍了不同技术客观和公正的评估。严重碎片化的fuzzing的生态阻止了研究者组合多种技术来实现新的原型系统。</p>
<p>为了解决这个问题，这篇文章提出了LibAFL，一个框架来构建模块化和可重用的fuzzer。文章讨论了fuzzing中的不同模块，并将其映射到一个可扩展的框架中去。LibAFL允许研究者和工程师去扩展核心的fuzzer流水线，同时可以分享他们的模块，以便未来的评估。作为LibAFL的一部分，作者已经整合了20多个前人的工作，并且做了相当多的实验来显示我们框架在整合评估不同方法的有效性。作者希望这能够帮助fuzzing领域进步，同时为未来可比较性和可扩展的研究打下基础。</p>
<h2 id="fuzzing的9个模块"><a href="#fuzzing的9个模块" class="headerlink" title="fuzzing的9个模块"></a>fuzzing的9个模块</h2><p>input：程序的输入，或者从外部获取的数据，输入到系统中，影响了系统的行为。这样的数据就是输入。</p>
<p>作者将输入（Input）定义为程序输入的内部表示。举个简单的例子，程序的输入就是一个单字节数组。许多fuzzer直接存储并操作字节数组，并把结果传到目标程序。</p>
<p>然而，字节数组并不是输入的理想表示形式。就比如，如果目标程序希望接受一系列的系统调用的话，字节数组就不合适了。另外一种方式是把输入存储为抽象语法树（AST）的形式，这样可以保留语法信息。还有其他的工作是把输入处理为一序列的tokens或者语言的IR。</p>
<p>Corpus：输入的存储以及关联的元数据。不同的存储会影响fuzzer的能力，比如，corpus存在内存中，会使得fuzzer运行很快，但是同时也会很快消耗完内存。而存储在disk的corpus虽然也可以检查fuzzer的状态，但是会引入disk操作的开销。</p>
<p>主流的fuzzer都存在disk，但这个选择影响了并行fuzzing的扩展性，并且需要标准库来实现文件IO的操作。</p>
<p>在libafl的模型中，一个fuzzer至少需要两个单独的corpora，一个用来存储有趣的测试样例，作为fuzzer进化算法的组件。另一个用来存储solutions，也就是满足fuzzer目标的测试样例，例如导致程序崩溃的crash。</p>
<p>Scheduler：调度器是和corpus紧密连接的一个模块。这个模块主要是告诉fuzzer下一个要fuzz的测试样例。最原始的调度器的实现有FIFO（先进先出）或者随机选择。更复杂的调度去可能会使用一些概率算法或者应用其他的调度器到corpus的子集里去。</p>
<p>Stage：stage是一个组件，定义了从corpus操作测试样例的一个行为。通常来说，调度器选择了一个测试样例后，fuzzer会在每个阶段执行给定的输入。Stage是一个很广的实体，通常作为唤起变异器的组件（random，havoc stage in AFL）</p>
<p>另外一个很知名的stage是最小化的过程。他主要是把测试样例的大小弄小，同时不改变测试样例的覆盖率。</p>
<p>Observer：观察器从目标程序的执行中提供信息。比较知名的观察器就是覆盖率映射表。这个映射表包含了执行过的每一条边。这个信息不会被多次运行的时候保持不变，他是程序的动态属性。（AFL的bitmap）</p>
<p>Executor：主要负责执行目标程序。在作者的模型中，执行器不仅是如何执行目标程序，也包括所有执行过程中的非法操作。所以执行器负责告诉程序关于fuzz想要用的输入。</p>
<p>Feedback：反馈是用来区分程序的执行的输出是否有趣。理论上，这个信息用来确定对应的输入是否被加到corpus中。大多数情况下，feedback和observer是深度关联的。但是这两个是不同的概念。事实上，feedback通常处理多个观察器传来的信息来确定执行是否是有趣的。而有趣这个概念是很抽象的，通常可以理解为是否发现了新的东西（比如发现了新的边）。</p>
<p>识别有趣输入的过程在fuzzing中也有第二个重要目标，找到能够满足特定的属性的solution，比如目标程序中一个可观测到的crash。</p>
<p>Mutator：将一个输入或者多个输入变成新的输入。变异器可以组合多个其他的变异器，并且通常与一个特定的输入类型有关。在传统的fuzzer里，变异器包含许多位级别的操作，比如位翻转或者基本块交换。一个变异器也可以依据输入格式来变异。比如通过交换AST树上的一个节点来实现变异。</p>
<p>Generator:从scratch中生成一个新的输入。例如NAUTILUS使用基于语法的生成器创建初始的corpus和子树生成器作为它的语法变异器。</p>
<h2 id="框架结构"><a href="#框架结构" class="headerlink" title="框架结构"></a>框架结构</h2><h3 id="设计理念和顶层设计"><a href="#设计理念和顶层设计" class="headerlink" title="设计理念和顶层设计"></a>设计理念和顶层设计</h3><p>LibAFL的目的是构建一种基于可重用组件和可靠、快速和可扩展的先进技术的模块化设计的新时代fuzzer。</p>
<p>libafl的框架基于三个关键原则：</p>
<ol>
<li><p>Extensibility：允许用户交换第三章介绍的实体的不同实现，而不需要改动其他的部分。这样可以允许不同的技术融合到一起。</p>
</li>
<li><p>Portability：大多数的fuzzer是操作系统特定的。要不只能对unix程序，要不是windows。为了避免这个缺点，libafl以一种不依赖系统的方式来设计核心库。而且，为了最大化可移植性，实现了LibAFL的子集，包含了所有的核心组件，而不需要任何标准库的依赖。因此，可以让用户对bare-metal目标（比如嵌入式系统、内核）写fuzzer。</p>
</li>
<li><p>Scalability：设计的选择不能和fuzzer的多核运行的特性相矛盾。因为这点，libafl设计了一个基于事件的接口，能够在fuzzer之间相互通信。</p>
</li>
</ol>
<p>libfuzzer虽然能够在不同的操作系统上用，但是不能不需要标准库来进行编译。AFL自身是基于disk进行IO通信，同时用了大量的系统调用，比如fork，导致其扩展到多核上的效果不好。其他扩展性更好的方案，比如HONGGFUZZ依然是基于系统调用来控制目标并且在多个并行的线程中保留一个共享的状态。</p>
<p>为了创建一个fuzzing的框架，能够满足上面的三个目标，围绕三个核心库设计了LibAFL。</p>
<ul>
<li><p>LibAFl Core是主要的库，包含fuzzing的组件和他们相应的组件。这个库的大部分都依赖于Rust core+alloc，因此，可以在没有标准库的情况下运行。</p>
</li>
<li><p>LibAFL Targets包含了在目标程序里的代码。比如用来追踪覆盖率的运行时的库。</p>
</li>
<li><p>LibAFL CC提供了函数来写编译器的wrapper，方便用户来进行插桩。</p>
</li>
</ul>
<p>除了这三个核心库，也包含插桩后端提供API来让libafl可以应用到不同的执行引擎，比如QEMU和Frida。</p>
<h3 id="核心库"><a href="#核心库" class="headerlink" title="核心库"></a>核心库</h3><p>libafl的核心架构如下图所示：</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image_E6o7fCJS8U.png"></p>
<p>大部分的组件都是和前面的实体是一对一映射的关系。有三个多出来的组件是：State、Fuzzer和Events Manager。</p>
<p>每个组件都映射为一个Rust的泛型特征，运行它和其他不同的组件进行组合。</p>
<p>Zero-cost Abstraction Extensibility的代价是引入抽象，通常会影响性能。由于性能对于fuzzing的影响很大，libafl的设计是一种灵活的抽象，而且不会在运行时引入很大的开销。</p>
<p>在初期的测试阶段，libafl的作者没有选择传统的面向对象的模式，而是使用泛型特征。所以使用rust语言的设计，来让编译器做进一步的优化。</p>
<p>选择Rust的两个原因：</p>
<ul>
<li><p>编译器优化友好</p>
</li>
<li><p>相当内联</p>
</li>
</ul>
<p>State 是所有合法数据在的地方。所有进化算法的数据都存在state里，比如执行的次数，伪随机数，语料库。</p>
<p>由于一些类型的反馈也需要保存状态，比如覆盖率。因此，libafl引入了FeedbackState组件来连接State和Feedback。feedback状态的实例包含在状态里，并且在fuzzing过程的开始就生成了。</p>
<p>找个地方放置fuzzer的数据主要是利用Rust的序列化的特性。序列化和去序列化一个状态，能够让基于libafl的fuzer在内部的某个特定状态停止和重启。</p>
<p>Fuzzer是一个定义fuzzer能做什么的容器。它包含feedback，objectives，scheduler，以及其他可能改变fuzzer状态的操作。这些来自fuzzer的过程被隔开了，为的是遵守Rust语言的借用规则。遵守借用规则是以防一些操作同时改变了fuzzer和state。</p>
<p>fuzzer的主要功能：</p>
<ul>
<li><p>FuzzOne：一个测试样例要如何处理</p>
</li>
<li><p>InputEvaluation：如何评估一个新的输入</p>
</li>
</ul>
<p>EventManager：创建和处理事件的一个接口，可以用来实现多核fuzzer或者单纯的日志记录。</p>
<p>MetadataSystem：fuzzing算法经常需要一个测试样例的其他数据，或者fuzzer的全部状态。因此，libafl需要提供一种方式来扩展测试样例的数据和在状态里的数据。</p>
<p>为了提供这种扩展能力，同时保证简单和性能，libafl设计了一个元数据系统。同时，测试样例和状态保留了一个映射表，作为这个元数据的扩展容器。这样的话，不同但是相关的模块可以操作同一个元数据，并且可以忽视其他模块对元数据的处理。这是libafl唯一引入的一点运行开销的地方，主要是由于映射表的查询导致的。</p>
<p>Composable Feedbacks 。一个fuzzer可能需要组合多种feedbacks来评估给定的输入有多有趣。libafl里通过使用逻辑运算符来组合feedback。比如，要对crash进行去重的话，并且收集两种反馈，一个是认为导致崩溃的输入是有趣的，另一个是触发了一个新的栈的路径。这种情形下，可以通过使用逻辑运算符AND来组合这两种反馈，从而实现crash的去重。</p>
<p>Monitor。最后一个fuzzer的组件是监控器。它的功能主要是保留触发事件的数据以及展示给用户。</p>
<h3 id="插桩后端"><a href="#插桩后端" class="headerlink" title="插桩后端"></a>插桩后端</h3><p>libafl也可以很容易地导入其他的插桩后端，比如二进制翻译器，或者一个简单的编译插桩的pass。默认情况下，libafl提供了额外的库来与一些知名的插桩后端相联，比如LLVM，SanitizerCoverage，Qemu usermode和Frida。</p>
<p>除了上面这几个，还提供了concolic execution。因此也整合了SymCC和SymQEMU。</p>
<p>目前已部分支持TinyInst去对windows，macOS的程序进行插桩，以及NYX这个hypervisor级别的快照fuzzing。</p>
<h2 id="5-应用与实验"><a href="#5-应用与实验" class="headerlink" title="5 应用与实验"></a>5 应用与实验</h2><p>实验部分主要针对四个问题进行评估：</p>
<ul>
<li><p>roadblocks bypassing</p>
</li>
<li><p>structure-aware fuzzing</p>
</li>
<li><p>corpus scheduling</p>
</li>
<li><p>energy assignment</p>
</li>
</ul>
<p>主要是看libafl在这四个问题上的表现效果。下面的表格列举了目前libafl支持的一些特性。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image_wD-5CXP0uL.png"></p>
<h3 id="5-1-Bypassing-Roadblocks"><a href="#5-1-Bypassing-Roadblocks" class="headerlink" title="5.1 Bypassing Roadblocks"></a>5.1 Bypassing Roadblocks</h3><p>bypassing roadblocks指的是通过绕过很难求解的约束来增加代码覆盖率。比如，多字节比较对于通过随机的遗传变异是很难绕过的。因为解空间很大，盲目地猜测是不切实际的。Libafl提供了几种现有的技术来绕过这些roadblocks。</p>
<ul>
<li><p>value-profile（libfuzzer）：通过最大化两个指令的操作数的匹配的位来求解比较指令</p>
</li>
<li><p>cmplog（AFL++）：通过找到并替换input-to-state values。对比较指令和将两个指针作为参数的函数进行插桩。并且在运行时记录相关的值到映射表。然后变异器匹配输入的模式，并用比较指令另一个操作数的值替代输入。</p>
</li>
<li><p>autotokens（AFL++）：从比较指令中提取tokens，从函数中提取立即数，编码到二进制的段里。然后把这些token放在状态的元数据字典里，然后在变异器使用这些tokens。由于这种方法不引入开销，所以将这种方法作为baseline。</p>
</li>
</ul>
<p>最后的实验结果是cmplog（95.94）&gt;value_profile_complog（95.03） &gt; plain（94.65） &gt; value_profile（90.13）。</p>
<h3 id="5-2-Structure-aware-Fuzzing"><a href="#5-2-Structure-aware-Fuzzing" class="headerlink" title="5.2 Structure-aware Fuzzing"></a>5.2 Structure-aware Fuzzing</h3><p>基于遗传算法的变异器对于一些结构化的输入表现不好。针对这个问题，一种解决方法是让fuzzer意识到输入的格式。Libafl也提供了几种现有的技术，来处理结构化的输入。</p>
<ul>
<li><p>NAUTILUS：一种基于语法的覆盖率导向的fuzzer。他的核心思想是在语法树上进行变异。</p>
</li>
<li><p>GRAMATRON：利用一种grammar-to-automata的转换方法来实现高效的变异器。</p>
</li>
<li><p>GRIMOIRE：使用那些会增加覆盖率的部分输入作为tokens来构建树形的输入，并且做grammar-like的变异。他原本是对JavaScript语言进行fuzz的，但是libafl的实现是通用的，并且可以用到任何语言。</p>
</li>
</ul>
<p>评估这些方法的指标为未覆盖的bug的数目。因为这类fuzzer的有效性并不依赖于代码覆盖率。</p>
<p>实验结果如下，grimoire的表现效果最好。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image_ruM4Zc3MPF.png"></p>
<p>除此之外，作者还将前面实验表现不好的nautius与一个不相关的技术MOPT结合，来看二者结合的效果，实验如下图所示。总体来说，MOPT的效果与目标程序有很大的关系。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image_b7LyMnTdOe.png"></p>
<h3 id="5-3-Corpus-Scheduling"><a href="#5-3-Corpus-Scheduling" class="headerlink" title="5.3 Corpus Scheduling"></a>5.3 Corpus Scheduling</h3><p>从语料库中选择哪一个测试样例来用是许多研究的重点。最简单的是随机选择或者FIFO队列。libafl提供了这两种方法，也包括其他的调度器。</p>
<ul>
<li><p>MinimizerScheduler（AFL）：基于执行速度和输入的长度，同时保持最大的覆盖率来选择种子。</p>
</li>
<li><p>weighted（AFL++）：基于概率进行抽样，概率的分数使用各种指标，包括执行的时间，覆盖率映射表的大小。</p>
</li>
<li><p>accounting（TORTOISEFUZZ）：使用三种安全影响指标来选择输入，基本块和函数粒度级别的内存操作，loop back edges（回到循环的边）的数目。</p>
</li>
</ul>
<p>实验结果：weighted&gt;minimizer&gt;accounting&gt;rand</p>
<p>并且这几个差别不是很大。尽管有相当多的研究在做这个问题。</p>
<p>作者认为可能是libafl的吞吐量很大，导致是在这些程序上运行的很快，因此就看不出差别。</p>
<h3 id="5-4-Energy-Assignment"><a href="#5-4-Energy-Assignment" class="headerlink" title="5.4 Energy Assignment"></a>5.4 Energy Assignment</h3><p>能量分配主要是回答一个输入需要变异多少次生成一个测试样例的问题。最原始的方法是使用一个常数值。最常见的简单的方法是根据时间间隔来分配一个随机值。libafl提供了这种方法，名为plain。AFLFast工作里提出了六种不同的算法：exploit，explore，coe，fast，lin和quad。</p>
<p>实验结果：explore&gt;fast&gt;plain&gt;coe</p>
<p>同样，他们的区别很小。</p>
<h3 id="5-5-通用的bit-level-Fuzzer"><a href="#5-5-通用的bit-level-Fuzzer" class="headerlink" title="5.5 通用的bit-level Fuzzer"></a>5.5 通用的bit-level Fuzzer</h3><p>这部分就把前面的四个问题里最好的技术整合到一起，和其他成熟的fuzzer（AFL++，Honggfuzz，libfuzzer）进行评估。</p>
<p>总体上效果要优于现有的fuzzer。</p>
<p>具体的实验结果在该网址可以看到：<a href="https://www.fuzzbench.com/reports/experimental/2022-04-11-libafl/index.html" title="https://www.fuzzbench.com/reports/experimental/2022-04-11-libafl/index.html">https://www.fuzzbench.com/reports/experimental/2022-04-11-libafl/index.html</a></p>
<h3 id="5-6-Differential-Fuzzing"><a href="#5-6-Differential-Fuzzing" class="headerlink" title="5.6 Differential Fuzzing"></a>5.6 Differential Fuzzing</h3><p>作者为了证明libafl不止可以用于构建基于覆盖率导向的模糊测试。亲身用两天，900行代码复现了NeoDiff。这是一个对比的模糊测试，面向的是以太坊虚拟机。</p>
<p>NeoDiff，原本是基于python写的，会去比较基于同样的输入比较两个以太坊虚拟机的执行结果。具体来说，它使用了状态哈希的方法。就是将寄存器的值，内存和栈上每个指令的概率抽样进行哈希。它使用的反馈是类型哈希（type hash），操作码的哈希以及每个指令在栈上前两个东西的类型。任何输入产生了新的类型哈希，就会被加入到语料库中。</p>
<p>并且，作者拿基于libafl复现的NeoDIFF与原始版本对比实验结果，发现libafl的效果要比原本的好很多。作者认为是语言实现上的问题，rust实现要比python实现的好很多。</p>
<h3 id="5-7第三方应用"><a href="#5-7第三方应用" class="headerlink" title="5.7第三方应用"></a>5.7第三方应用</h3><p>libafl已经被很多新用户使用了。这些用户之前没有使用这些框架的经验。</p>
<ol>
<li><p>TLSPUFFIN：结合fuzzing和模型测试，实现了对TLS协议的fuzzer。</p>
</li>
<li><p>TARTIFLETTE：基于KVM的快照fuzzer。提供了一种新的执行器，通过系统调用模拟和覆盖率追踪的插桩来将Linux ELF当作是VM进行运行。</p>
</li>
<li><p>NANAFZZ：检查竞态条件的漏洞的fuzzer。</p>
</li>
</ol>
<h2 id="6-局限性"><a href="#6-局限性" class="headerlink" title="6 局限性"></a>6 局限性</h2><p>没有包含Link Time Optimization pass来构建程序的控制流图，导致不支持大部分的定向模糊测试。</p>
<p>libafl提供了强大的concolic tracing的API，可以用来扩展SymCC和SymQEMU来过滤约束和符号路径通信。目前，libafl使用Z3来生成新的测试样例。然而传统的concolic fuzzer的缺陷，这个框架也不能解决。主要原因是：</p>
<ol>
<li><p>求解器时间开销和资源开销都很大。</p>
</li>
<li><p>fuzzer和concolic结合的并不好。即使当一个求解器生成了复杂约束的测试样例，也很难让fuzzer去变异生成的测试样例，而不去破坏求解出来表达式的合法性。</p>
</li>
</ol>
<p>最后是关于这篇论文的一些链接：</p>
<ul>
<li><p>libafl的github仓库：<a href="https://github.com/AFLplusplus/LibAFL" title="https://github.com/AFLplusplus/LibAFL">https://github.com/AFLplusplus/LibAFL</a></p>
</li>
<li><p>论文地址：<a href="https://www.eurecom.fr/publication/6973/download/sec-publi-6973.pdf" title="https://www.eurecom.fr/publication/6973/download/sec-publi-6973.pdf">https://www.eurecom.fr/publication/6973/download/sec-publi-6973.pdf</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title>KLEE 源码阅读笔记</title>
    <url>/2021/05/20/KLEE%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="KLEE-源码阅读笔记"><a href="#KLEE-源码阅读笔记" class="headerlink" title="KLEE 源码阅读笔记"></a>KLEE 源码阅读笔记</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>KLEE是基于LLVM的符号执行工具，发表于2008年的OSDI会议上，至今已被引用3000多次，基于该工作的研究也有150多篇，其中有30多个是开源工作。本文从KLEE源码入手，希望能让读者了解klee工作的基本原理。</p>
<h2 id="1-klee-基本框架"><a href="#1-klee-基本框架" class="headerlink" title="1. klee 基本框架"></a>1. klee 基本框架</h2><p>KLEE是EXE工作的重新设计。从高层面来说，KLEE像一个符号化进程的操作系统和解释器。程序源码被LLVM编译为类似RISC的虚拟指令集，KLEE直接解释指令，并将指令映射为约束条件。</p>
<p>KLEE的核心是一个解释器，循环地从状态池里选择状态，并在那个状态下符号化地执行每条指令。直到状态池里没有状态了，或者时间超过了用户设定的。</p>
<p>符号执行引擎存储的状态的寄存器、栈或者堆对象，都是表达式形式的，而非普通进程里的具体值。表达式的叶子节点是符号化的变量或者常量。还可以是LLVM中间层语言操作（算术运算、比较、内存访问）的内部节点。</p>
<p>符号执行大部分的指令都很直接。比如要符号执行一个LLVM加法运算。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%dst = add i32 %src0, %src1</span><br></pre></td></tr></table></figure>

<p>KLEE直接从src0和src1里取出加数，并且写一个新的表达式Add(%src0,%src1)到dst寄存器里。如果操作数都是具体值，就直接加好，返回一个常数表达式。</p>
<p>条件分支是布尔表达式，并且会根据条件为真或假改变状态的指令指针。KLEE去查询约束求解器来确定当前路径上的分支条件是否恒为真或假。如果恒为真或假，就更新指令指针到预计的位置。反之两种分支都有可能。然后KLEE就会去复制当前状态，这样就可以同时探索两条路径，并且同时更新指令指针和路径条件。</p>
<p>潜在的危险操作也会生成一个分支。比如一个除法操作就会生成一个分支去检测除数是不是0。这些分支的工作方式和普通分支是一样的。当检查成功，即检测出错误的时候，会继续执行条件为假的路径，也就是添加相反的约束，比如使得除数不为0的约束。此外，还会为错误生成测试样例，并且终止检测出错误的状态。</p>
<p>至于其他的危险操作，比如load和store指令，也会去检查。这些例子里，就会去检查地址是不是在合法内存对象里。然而，store和load指令需要额外的编译。最直接的表示内存的方式是flat byte array。这种情况下，load和store就会分别简单地映射为数组读和写表达式。</p>
<p>然而，KLEE使用的约束求解器不能解决这种约束。于是，KLEE将每个要检查代码的内存对象映射到一个单独的STP数组里。这种方式提高了性能，因为这让STP无视了表达式没有引用的数组。</p>
<p>许多操作比如边界检查，对象级的copy-on-write）需要对象特定的信息。如果一个指针指向很多对象，这些操作就很难实现。为了简化实现，KLEE用以下方式回避了这个问题。当一个解引用的指针p指向N个对象时，KLEE复制当前状态N次。在每个状态，KLEE限制指针p在其对象的边界内，然后实现读或写操作。虽然这个方法对于有很大points-to 集合的指针的开销很大，但实际情况中，大部分的符号指针只指向1个对象，所以这个优化还是可以的。</p>
<h2 id="2-klee代码架构"><a href="#2-klee代码架构" class="headerlink" title="2. klee代码架构"></a>2. klee代码架构</h2><p>从klee官网的开发者指南，我们可以知道klee源码的大致结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|-- include //包含公共的头文件</span><br><span class="line">|-- tools //所有KLEE的二进制的main都在这里，有些是python脚本</span><br><span class="line">|-- lib //包含大部分的源码</span><br><span class="line">|   |-- Core //包含解释和执行LLVM字节码和KLEE内存模型。</span><br><span class="line">|   |-- Expr // klee的表达式库</span><br><span class="line">|   |-- Module //包含在执行LLVM字节码前的一些操作代码。比如链接POSIX运行函数等等。</span><br><span class="line">|   |-- Solver//包含所有求解器</span><br><span class="line">|-- runtime//包含各种KLEE的运行时支持。</span><br><span class="line">|-- test//包含一些小的C程序和LLVM的字节码，用来给KLEE做回归测试</span><br></pre></td></tr></table></figure>

<p>由上面的结构可以知道，如果要修改KLEE的话，基本上是在lib&#x2F;core目录下进行修改。现在看看lib&#x2F;core目录下都有哪些代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|-- AddressSpace.cpp</span><br><span class="line">|-- AddressSpace.h</span><br><span class="line">|-- CallPathManager.cpp</span><br><span class="line">|-- CallPathManager.h</span><br><span class="line">|-- Context.cpp</span><br><span class="line">|-- Context.h</span><br><span class="line">|-- CoreStats.cpp</span><br><span class="line">|-- CoreStats.h</span><br><span class="line">|-- ExecutionState.cpp</span><br><span class="line">|-- ExecutionState.h</span><br><span class="line">|-- Executor.cpp</span><br><span class="line">|-- Executor.h</span><br><span class="line">|-- ExecutorUtil.cpp</span><br><span class="line">|-- ExternalDispatcher.cpp</span><br><span class="line">|-- ExternalDispatcher.h</span><br><span class="line">|-- GetElementPtrTypeIterator.h</span><br><span class="line">|-- ImpliedValue.cpp</span><br><span class="line">|-- ImpliedValue.h</span><br><span class="line">|-- Memory.cpp</span><br><span class="line">|-- Memory.h</span><br><span class="line">|-- MemoryManager.cpp</span><br><span class="line">|-- MemoryManager.h</span><br><span class="line">|-- MergeHandler.cpp</span><br><span class="line">|-- MergeHandler.h</span><br><span class="line">|-- PTree.cpp</span><br><span class="line">|-- PTree.h</span><br><span class="line">|-- Searcher.cpp</span><br><span class="line">|-- Searcher.h</span><br><span class="line">|-- SeedInfo.cpp</span><br><span class="line">|-- SeedInfo.h</span><br><span class="line">|-- SpecialFunctionHandler.cpp</span><br><span class="line">|-- SpecialFunctionHandler.h</span><br><span class="line">|-- StatsTracker.cpp</span><br><span class="line">|-- StatsTracker.h</span><br><span class="line">|-- TimingSolver.cpp</span><br><span class="line">|-- TimingSolver.h</span><br><span class="line">|-- UserSearcher.cpp</span><br><span class="line">|-- UserSearcher.h</span><br></pre></td></tr></table></figure>

<p>咋看上去有一点多。去掉头文件就少一半，大概将近二十个代码。这里我们就先从Executor.cpp这里开始看，这里也是解释器的主循环所在的代码。</p>
<h2 id="3-klee的执行器Executor"><a href="#3-klee的执行器Executor" class="headerlink" title="3. klee的执行器Executor"></a>3. klee的执行器Executor</h2><p>解释器的主循环代码位于Executor.cpp的run函数里。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Executor::run</span><span class="params">(ExecutionState &amp;initialState)</span> &#123;</span><br><span class="line">  bindModuleConstants();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Delay init till now so that ticks don&#x27;t accrue during optimization and such.</span></span><br><span class="line">  timers.reset();</span><br><span class="line"></span><br><span class="line">  states.insert(&amp;initialState);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (usingSeeds) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  searcher = constructUserSearcher(*this);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;ExecutionState *&gt; <span class="title function_">newStates</span><span class="params">(states.begin(), states.end())</span>;</span><br><span class="line">  searcher-&gt;update(<span class="number">0</span>, newStates, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;ExecutionState *&gt;());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// main interpreter loop</span></span><br><span class="line">  <span class="keyword">while</span> (!states.empty() &amp;&amp; !haltExecution) &#123;</span><br><span class="line">    ExecutionState &amp;state = searcher-&gt;selectState();</span><br><span class="line">    KInstruction *ki = state.pc;</span><br><span class="line">    stepInstruction(state);</span><br><span class="line"></span><br><span class="line">    executeInstruction(state, ki);</span><br><span class="line">    timers.invoke();</span><br><span class="line">    <span class="keyword">if</span> (::dumpStates) dumpStates();</span><br><span class="line">    <span class="keyword">if</span> (::dumpPTree) dumpPTree();</span><br><span class="line"></span><br><span class="line">    updateStates(&amp;state);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!checkMemoryUsage()) &#123;</span><br><span class="line">      <span class="comment">// update searchers when states were terminated early due to memory pressure</span></span><br><span class="line">      updateStates(nullptr);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码注释&#x2F;&#x2F;main  interpreter loop往下看，代码的逻辑基本和前面说的差不多，由搜索器searcher选择一个状态，然后执行指令，并且更新状态。下面我们来看组成这个循环的四个主要函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">selectState();</span><br><span class="line">stepInstruction(state);</span><br><span class="line">executeInstruction(state, ki);</span><br><span class="line">updateStates(&amp;state);</span><br></pre></td></tr></table></figure>

<p>将run函数的大致流程可以用下图表示。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20210505204501326.png" alt="image-20210505204501326"></p>
<p>selectState函数在Searcher.cpp里，并且每种search的选择状态实现也不一样。比如DFSSearcer就直接返回状态池的最后一个状态。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ExecutionState &amp;DFSSearcher::selectState() &#123;</span><br><span class="line">  return *states.back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BFSSearcher返回第一个状态。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ExecutionState &amp;BFSSearcher::selectState() &#123;</span><br><span class="line">  return *states.front();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>KLEE还实现了很多Searcher，感兴趣地可以去Searcher.cpp代码里看。</p>
<p>下面的代码是stepInstruction，逻辑比较简单，主要就是将PC+1。并且判断一下如果指令数量到达最大指令数量，就将haltExecution标志位置为真。为什么不直接将这个逻辑整合到执行指令里去呢？除了要判断指令的数目这点外，也是为了更好地扩展。实际上就有工作在stepInstuction和executeInstruction之间做了扩展，比如基于klee扩展的一个工作BovInspector就在此处加了一个验证函数BFO_Check函数来验证缓冲区溢出漏洞。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void Executor::stepInstruction(ExecutionState &amp;state) &#123;</span><br><span class="line">  printDebugInstructions(state);</span><br><span class="line">  if (statsTracker)</span><br><span class="line">    statsTracker-&gt;stepInstruction(state);</span><br><span class="line"></span><br><span class="line">  ++stats::instructions;</span><br><span class="line">  ++state.steppedInstructions;</span><br><span class="line">  state.prevPC = state.pc;</span><br><span class="line">  ++state.pc;</span><br><span class="line"></span><br><span class="line">  if (stats::instructions == MaxInstructions)</span><br><span class="line">    haltExecution = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是executeInstruction()函数，这个函数代码量比较大，核心就是一个很大的switch语句，对于不同的指令，设置了不同的执行方式。下图展示了KLEE建模的指令。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20210505195953723.png" alt="image-20210505195953723"></p>
<p>下面代码节选了内存指令的实现。eval函数的作用是求解表达式。对angr有了解的，可能会发现angr里也有eval这个接口。这部分对指令的建模代码看起来有点晦涩，但大体上可以看出klee对IR层的每条指令都做了细致的处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void Executor::executeInstruction(ExecutionState &amp;state, KInstruction *ki) &#123;</span><br><span class="line">  Instruction *i = ki-&gt;inst;</span><br><span class="line">  switch (i-&gt;getOpcode()) &#123;</span><br><span class="line">  ...</span><br><span class="line">   case Instruction::Alloca: &#123;</span><br><span class="line">    AllocaInst *ai = cast&lt;AllocaInst&gt;(i);</span><br><span class="line">    unsigned elementSize = </span><br><span class="line">      kmodule-&gt;targetData-&gt;getTypeStoreSize(ai-&gt;getAllocatedType());</span><br><span class="line">    ref&lt;Expr&gt; size = Expr::createPointer(elementSize);</span><br><span class="line">    if (ai-&gt;isArrayAllocation()) &#123;</span><br><span class="line">      ref&lt;Expr&gt; count = eval(ki, 0, state).value;</span><br><span class="line">      count = Expr::createZExtToPointerWidth(count);</span><br><span class="line">      size = MulExpr::create(size, count);</span><br><span class="line">    &#125;</span><br><span class="line">    executeAlloc(state, size, true, ki);</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  case Instruction::Load: &#123;</span><br><span class="line">    ref&lt;Expr&gt; base = eval(ki, 0, state).value;</span><br><span class="line">    executeMemoryOperation(state, false, base, 0, ki);</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line">  case Instruction::Store: &#123;</span><br><span class="line">    ref&lt;Expr&gt; base = eval(ki, 1, state).value;</span><br><span class="line">    ref&lt;Expr&gt; value = eval(ki, 0, state).value;</span><br><span class="line">    executeMemoryOperation(state, true, base, value, 0);</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p>接下来看更新状态的代码。主要逻辑就是把addedStates的状态加到状态池里，removedStates的状态移出状态池里。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void Executor::updateStates(ExecutionState *current) &#123;</span><br><span class="line">  if (searcher) &#123;</span><br><span class="line">    searcher-&gt;update(current, addedStates, removedStates);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  states.insert(addedStates.begin(), addedStates.end());</span><br><span class="line">  addedStates.clear();</span><br><span class="line"></span><br><span class="line">  for (std::vector&lt;ExecutionState *&gt;::iterator it = removedStates.begin(),</span><br><span class="line">                                               ie = removedStates.end();</span><br><span class="line">       it != ie; ++it) &#123;</span><br><span class="line">    ExecutionState *es = *it;</span><br><span class="line">    std::set&lt;ExecutionState*&gt;::iterator it2 = states.find(es);</span><br><span class="line">    assert(it2!=states.end());</span><br><span class="line">    states.erase(it2);</span><br><span class="line">    std::map&lt;ExecutionState*, std::vector&lt;SeedInfo&gt; &gt;::iterator it3 = </span><br><span class="line">      seedMap.find(es);</span><br><span class="line">    if (it3 != seedMap.end())</span><br><span class="line">      seedMap.erase(it3);</span><br><span class="line">    processTree-&gt;remove(es-&gt;ptreeNode);</span><br><span class="line">    delete es;</span><br><span class="line">  &#125;</span><br><span class="line">  removedStates.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-klee的状态"><a href="#4-klee的状态" class="headerlink" title="4. klee的状态"></a>4. klee的状态</h2><p>从Executor.cpp的代码里，我们可以发现，klee里一个很重要的概念就是state。解释器里的几个重要流程的操作对象都是状态。接下来看看klee的状态都有哪些部分组成。这部分代码在ExecutionState.cpp。从下面的代码中，可以发现状态里包含了很多信息，包括pc，栈约束条件等等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ExecutionState::ExecutionState(const ExecutionState&amp; state):</span><br><span class="line">    pc(state.pc),</span><br><span class="line">    prevPC(state.prevPC),</span><br><span class="line">    stack(state.stack),</span><br><span class="line">    incomingBBIndex(state.incomingBBIndex),</span><br><span class="line">    depth(state.depth),</span><br><span class="line">    addressSpace(state.addressSpace),</span><br><span class="line">    constraints(state.constraints),</span><br><span class="line">    pathOS(state.pathOS),</span><br><span class="line">    symPathOS(state.symPathOS),</span><br><span class="line">    coveredLines(state.coveredLines),</span><br><span class="line">    symbolics(state.symbolics),</span><br><span class="line">    arrayNames(state.arrayNames),</span><br><span class="line">    openMergeStack(state.openMergeStack),</span><br><span class="line">    steppedInstructions(state.steppedInstructions),</span><br><span class="line">    instsSinceCovNew(state.instsSinceCovNew),</span><br><span class="line">    unwindingInformation(state.unwindingInformation</span><br><span class="line">                             ? state.unwindingInformation-&gt;clone()</span><br><span class="line">                             : nullptr),</span><br><span class="line">    coveredNew(state.coveredNew),</span><br><span class="line">    forkDisabled(state.forkDisabled) &#123;</span><br><span class="line">  for (const auto &amp;cur_mergehandler: openMergeStack)</span><br><span class="line">    cur_mergehandler-&gt;addOpenState(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>关于state的操作有以下几种，这部分里主要还是merge的逻辑比较复杂。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">branch // 处理分支情况，实际就是复制条件为false的状态</span><br><span class="line">pushFrame </span><br><span class="line">popFrame</span><br><span class="line">addSymbolic</span><br><span class="line">merge //合并状态</span><br><span class="line">dumpStack</span><br><span class="line">addConstraint //调用约束管理器添加约束</span><br></pre></td></tr></table></figure>

<h2 id="5-KLEE内存模型"><a href="#5-KLEE内存模型" class="headerlink" title="5. KLEE内存模型"></a>5. KLEE内存模型</h2><p>klee里还有个很重要的概念就是内存模型。在Memory.h里，我们可以看见有memory object的定义，可以知道memory object有以下属性，包括id，地址，内存对象的大小等等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MemoryObject(uint64_t _address, unsigned _size, </span><br><span class="line">             bool _isLocal, bool _isGlobal, bool _isFixed,</span><br><span class="line">             const llvm::Value *_allocSite,</span><br><span class="line">             MemoryManager *_parent)</span><br><span class="line">  : id(counter++),</span><br><span class="line">    address(_address),</span><br><span class="line">    size(_size),</span><br><span class="line">    name(&quot;unnamed&quot;),</span><br><span class="line">    isLocal(_isLocal),</span><br><span class="line">    isGlobal(_isGlobal),</span><br><span class="line">    isFixed(_isFixed),</span><br><span class="line">    isUserSpecified(false),</span><br><span class="line">    parent(_parent), </span><br><span class="line">    allocSite(_allocSite) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而这些内存对象由memory manager来进行管理，在MemoryManager.h里可以看到memory manger负责分配内存、释放内存等等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public:</span><br><span class="line">  MemoryManager(ArrayCache *arrayCache);</span><br><span class="line">  ~MemoryManager();</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Returns memory object which contains a handle to real virtual process</span><br><span class="line">   * memory.</span><br><span class="line">   */</span><br><span class="line">  MemoryObject *allocate(uint64_t size, bool isLocal, bool isGlobal,</span><br><span class="line">                         const llvm::Value *allocSite, size_t alignment);</span><br><span class="line">  MemoryObject *allocateFixed(uint64_t address, uint64_t size,</span><br><span class="line">                              const llvm::Value *allocSite);</span><br><span class="line">  void deallocate(const MemoryObject *mo);</span><br><span class="line">  void markFreed(MemoryObject *mo);</span><br><span class="line">  ArrayCache *getArrayCache() const &#123; return arrayCache; &#125;</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">   * Returns the size used by deterministic allocation in bytes</span><br><span class="line">   */</span><br><span class="line">  size_t getUsedDeterministicSize();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>前面提到的基于KLEE的工作BovInspector就在Memory.h里建立缓冲区的模型。下面代码就是BovInspector建立的缓冲区的模型。这也告诉我们，如果想要对什么对象建立模型，可以将代码写在Memory.h里。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class BufferObject &#123;</span><br><span class="line">private:</span><br><span class="line">	uint64_t startAddr;</span><br><span class="line">	uint64_t size;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	MemoryObject * mo;</span><br><span class="line">	uint64_t getStartAddr();</span><br><span class="line">	uint64_t getSize();</span><br><span class="line"></span><br><span class="line">	void setStartAddr(uint64_t addr);</span><br><span class="line">	void setSize(unsigned size);</span><br><span class="line">	BufferObject(MemoryObject * mo);</span><br><span class="line">&#125;;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>klee和angr都是符号执行工具，但两者不同的是，angr更像是一个框架，你可以利用框架实现你想要的功能，而klee则是封装比较好的一个工具，可以直接输入命令使用的。另外一个不同点是angr是针对二进制程序操作的，而klee是在LLVM字节码上弄的。</p>
<p>之前对于klee的了解仅仅停留在论文和官方文档，几条命令反复使用。但最近需要修改klee实现想要的功能时，仅仅停留在论文和官方文档就有点不够用了。尝试去看了代码，感觉收益颇丰，看的时候不禁恍然大悟，原来也有我看得懂的地方。</p>
<p>总的来说，klee是基于LLVM的一个很优秀的开源符号执行工具，十几年来都还在更新代码，目前来看功能应该比较完善了，但仍然有可扩展的空间，比如和别的静态分析技术结合，例如SVF(<a href="https://github.com/SVF-tools/SVF)%E3%80%82">https://github.com/SVF-tools/SVF)。</a></p>
<p>写的比较粗糙，希望大家能从这篇文章有所收获。</p>
<h2 id="7-参考资料"><a href="#7-参考资料" class="headerlink" title="7. 参考资料"></a>7. 参考资料</h2><p>0x1. klee官网：<a href="http://klee.github.io/">http://klee.github.io/</a></p>
<p>0x2. Cadar C, Dunbar D, Engler D R. Klee: unassisted and automatic generation of high-coverage tests for complex systems programs[C]&#x2F;&#x2F;OSDI. 2008, 8: 209-224.</p>
<p>0x3. klee源码：<a href="https://github.com/klee/klee">https://github.com/klee/klee</a><br>0x4. BovInspector : <a href="https://github.com/BovInspectorTool1/project">https://github.com/BovInspectorTool1/project</a></p>
]]></content>
      <tags>
        <tag>symbolic execution</tag>
      </tags>
  </entry>
  <entry>
    <title>【论文笔记】Regression Greybox Fuzzing</title>
    <url>/2022/01/21/Regression%20Greybox%20Fuzzing/</url>
    <content><![CDATA[<h1 id="Regression-Greybox-Fuzzing"><a href="#Regression-Greybox-Fuzzing" class="headerlink" title="Regression Greybox Fuzzing"></a>Regression Greybox Fuzzing</h1><blockquote>
<p>CCS 2021 的一篇关于模糊测试的文章，主要是利用git commit 的日志来去指导模糊测试，去测试最近变化过的地方。</p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>What you change is what you fuzz !在OSSFuzz里生成的报告里，大约77%的漏洞报告都是回归型的。对于一个新加进来的项目，每天可能会有2-3个漏洞报告。在刚开始这段漏洞爆发期过去后，后续每周有漏洞的频率大概是一周会有3-4个bug。这种常数的增长速率只能用回归率来解释。作者画了个漏洞是回归的概率与漏洞数目的图，从图上可以看出，后期产生的bug，有非常大的概率是回归的。漏洞是回归的意思就是漏洞是由最近的修改导致的。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20220120202319728.png" alt="image-20220120202319728"></p>
<p>文章基于这个发现提出了一种回归灰盒测试。能够针对最近变化频繁的代码进行测试。然而，对于任意的软件，是不可能对于每个commit进行单独测试。因此，回归灰盒测试能够同时fuzz 所有的commits，但是最近提出的commit具有更高的优先级。作者观察到大部分的代码都不会变化，而且相当的老。所以，实现了一种方法去加强感兴趣代码的fuzz力度。同样也修改了能量调度算法，并且引入了蚁群算法来分配更多的能量到那些会生成更多有趣输入的种子上去。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>现有的工具可以对单个commit进行fuzz，但是如果只对单个commit进行fuzz，可能会丢失掉没有测试的commit、跨越多个commit引起的漏洞。例如，早期的commit引入了一个漏洞，后期的commit用了这个数组，导致了漏洞，这种情况只对一个commit进行fuzz的AFLGo就没有办法解决。</p>
<p>而且对所有commit一次次地去fuzz，也是非常耗时的。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>改了三个部分：</p>
<ul>
<li>efficient fitness function<ul>
<li>每个基本块都是目标，只是权重不同</li>
<li>插桩实现，能够计算每个基本块的权重，运行时开销很小</li>
<li>运行时，基于输入经过的权重，计算每个输入的fitness 值，并且用归一化处理。</li>
</ul>
</li>
<li>amplifying weak signals<ul>
<li>只有一小部分的基本块频繁地变化，因此，如果直接计算输入经过的基本块的平均权重的话，高频的基本块能起到的作用很小</li>
<li>因此，采用对数和倒数的方法来加强这部分权重</li>
</ul>
</li>
<li>byte-level power schedule<ul>
<li>发现seed中的大部分字节对结果没啥影响</li>
<li>采用蚁群算法分配更多的能量到相应的字节</li>
</ul>
</li>
</ul>
<h3 id="Code-History-based-Instrumentation"><a href="#Code-History-based-Instrumentation" class="headerlink" title="Code History-based Instrumentation"></a>Code History-based Instrumentation</h3><p>理论上，要计算一个输入执行的代码有多老或者有多经常被修改，我们需要在执行的时候进行计算。计算的具体实现就是对代码进行插桩。插桩的算法如下：</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20220121111231089.png" alt="image-20220121111231089"></p>
<p>对于每个基本块BB，计算基本块的age和churn，然后使用AMPLIFY函数进行放大。修正全局变量阿尔法和count的值。</p>
<p>第三行的LASTCHANGED，计算基本块的age，age表示这个基本块最近被修改的时间。具体来说，是使用git blame去识别给定行L的commit C，然后提取C的日期，计算从commit C到当前commit经过了多少时间。基本块的age就是基本块里所有行的平均age。</p>
<p>第四行的NUMBEROFCHANGES，对于所有的基本块，RGF会去计算churn值。churn值指的是基本块被修改的频率。简单来说，就是计算commit C’ 的次数。C‘ 指的是连续两个版本R和R’的语法不同。</p>
<p>第五行的AMPLIFY，是放大age和churn的函数。作者观察到有很大一部分的基础基本块是不会被修改的。如果我们只计算基本块的均值，就会导致一些有趣的基本块的值特别小。最近的修改或者频繁地修改都会被忽略掉。作者做了几个实验来确定amplify函数，认为下面的amplify函数是最有效的。</p>
<p>$age’ &#x3D; \frac{1}{age}$</p>
<p>$churn’ &#x3D; log(churn)$</p>
<p>对于6-8行的inject，对于所有的基本块BB，插桩pass会在基本块的末端插入新的指令。主要是用来累加放大后的age和churn，以及计算执行的基本块的数目。</p>
<h3 id="Simulated-Annealing-based-Power-Schedule"><a href="#Simulated-Annealing-based-Power-Schedule" class="headerlink" title="Simulated Annealing-based Power Schedule"></a>Simulated Annealing-based Power Schedule</h3><p>回归灰盒测试（RGF）是一个优化问题，需要平衡exploration和exploitation。如果RGF只做探索，而不使用age和churn值，就和普通的灰盒测试没什么区别了。如果RGF只关心最优化的种子，就会失去探索其他漏洞的机会。全局优化技术就是用来处理这个trade-off的。</p>
<p>这篇文章处理这个全局优化问题，采用的是模拟退火算法。开始于探索阶段，然后迅速地切换到利用阶段。在灰盒测试中，，我们可以使用能量调度来调整这些搜索参数。能量调度对所有的种子赋予能量，一个种子的能量决定了用这个种子fuzzing的时间。</p>
<p>下面的种子调度算法，实现了：给定插桩的程序，种子库和输入，计算输入的能量。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20220122140823785.png" alt="image-20220122140823785"></p>
<p>第1行是前面插桩计算的阿尔法值，然后第2行对他求每个基本块的平均。第3行做归一化，将阿尔法值归到0-1之间。</p>
<p>第4行的ω是来处理探索（exploration）和利用（exploitation）的平衡的。其中$T_{exp} &#x3D; 0.05^{t.selectd}$是温度函数。在探索阶段，过低和过高的fitness的种子所获取的权重是一样的。比如，当一个种子没有被选择过，ω等于0.5，而当种子被选择了很多次之后，ω会接近归一化后的阿尔法值。</p>
<p>第5行是能量调度算法。基于前面的ω值来计算种子t的能量。其中$p_{afl}$指的是这个种子之前赋予过的能量。r是用来确定能量p的范围在$[2^{-r},2^{r}]$之间。</p>
<h3 id="Ant-Colony-Optimisation-ACO-based-Byte-Level-Power-Schedule"><a href="#Ant-Colony-Optimisation-ACO-based-Byte-Level-Power-Schedule" class="headerlink" title="Ant Colony Optimisation (ACO)-based Byte-Level Power Schedule"></a>Ant Colony Optimisation (ACO)-based Byte-Level Power Schedule</h3><p>污点分析经常用于分析哪些输入字节能够影响给定的代码位置，比如angora，vulscope等等fuzzer都用到了这种方法。然而，在这个场景里，不适合用污点分析。一是，污点分析的性能开销比较大。二是，这篇文章没有给出具体的位置给污点分析用来分析。</p>
<p>本文采用的是迭代式学习输入字节的分布，看哪部分的输入字节会让程序执行到有趣的地方。简单来说，就是计算每个字节的得分，分数越高越有可能到达感兴趣的地方。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20220122151209957.png" alt="image-20220122151209957"></p>
<p>要学习输入字节的分布的难点在于后续fuzzing迭代的字节选择依赖于前期fuzzing迭代时的字节选择。比如，在早期的迭代过程中，我们选了前面三个字节，并且成功了，就会导致前三个字节的得分变高，并且不断重复，就会导致前三个字节的权重变得很高。</p>
<p>为了解决这个问题，文中提出了一种蚁群优化算法。蚂蚁在他们的路径上留下信息素，使得其他的蚂蚁会沿着这条路径一块走。成功的路径会有更多的蚂蚁走，并且留下更多的信息素。然而，随着时间的过去，信息素会逐渐挥发，然后就给了新的机会去发现更好的路径。这里也类似，RGF基于输入的fitness，给输入的某个字节一个分数。然后，每个时间间隔过去后，所有字节的分数都会乘以0.9来模拟逐渐挥发。</p>
<p>具体的步骤可以分为以下四步：</p>
<ol>
<li>当一个新的输入t加入到种子语料库中<ul>
<li>计算种子t的fitness分数（归一化的阿尔法值）</li>
<li>将种子t的所有字节的分数置为0</li>
</ul>
</li>
<li>通过fuzzing种子t生成了一个新的输入t‘<ul>
<li>计算输入t’的fitness分数</li>
<li>找到t与t‘不同的字节</li>
<li>如果t’的fitness分数高于t，就累加一定的分数到这些不同的字节上</li>
</ul>
</li>
<li>当种子t被选为fuzzing时，以概率来fuzz每个字节，字节的分数越大，变异的概率越大。</li>
<li>在固定的时间间隔，RGF对所有的字节乘以小于1的数，来降低所有旧字节的分数。</li>
</ol>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>文章的假设是去fuzz最近变化的代码和变化频繁的代码，能够提高挖到回归漏洞的效率。因此，实验也是去验证这一点。所以，文章提出了三个研究问题。</p>
<p>RQ1：这种指导方式能不能提高灰盒测试工具的效率。（与AFL做对比实验）</p>
<p>RQ2：哪种启发式的指导的贡献更大？</p>
<ul>
<li>guided by age</li>
<li>guiided by churn</li>
<li>guided by both</li>
</ul>
<p>RQ3：crash的位置到底和最近变化、频繁变化这两个因素有没有关系？</p>
<p>RQ1的结果：1部分是AFL和AFLChurn在第一个cycle就找到了漏洞。而aflchurn需要跑完第1个cycle的指导作用才有用。3部分是两个都没跑出来crash。所以能看的是第2部分。看第2部分的结果，可以看到aflchurn是要优于第AFL的。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20220122153805252.png" alt="image-20220122153805252"></p>
<p>RQ2的结果：从表格上看，没有说哪方赢了很多。从某些特例来看，其中一者具有更好的效果。所以才需要将这两种启发式方法结合起来。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20220122154302853.png" alt="image-20220122154302853"></p>
<p>RQ3：给了很多图表，这里就简单说下结论：栈轨迹里的许多元素要比其他地方的代码变化得更多。在很多情况下，有一两个栈元素在代码中基本没有什么变化。大部分的元素都变化了相当多次。并且regressions和non-regressions之间并没有太大的区别。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看了这篇文章，基本上理解了模糊测试的文章需要改哪些部分可以应用到别的一个场景。（插桩、能量调度、fuzz哪些输入字节）</p>
<p>总体来说，是一篇原理不是很难，但是思路很清奇的文章。而且文章开源了代码和实验框架可供学习，太赞了！</p>
]]></content>
      <tags>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title>【论文笔记】Multiple Targets Directed Greybox Fuzzing</title>
    <url>/2022/10/13/Multiple%20Targets%20Directed%20Greybox%20Fuzzing/</url>
    <content><![CDATA[<h1 id="Multiple-Targets-Directed-Greybox-Fuzzing"><a href="#Multiple-Targets-Directed-Greybox-Fuzzing" class="headerlink" title="Multiple Targets Directed Greybox Fuzzing"></a>Multiple Targets Directed Greybox Fuzzing</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>定向模糊测试可以快速地发现和复现程序中的bugs。然而，由于他们静态的状态的区分和粗粒度的能量调度，现有的DGF在面对多目标的时候，表现很差。</p>
<p>本文提出了多目标定向灰盒测试，目的是探索程序的多个目标位置。具体来说，提出了一种新的策略来交互exploration和exploitation，以及一种考虑种子和目标位置关系的能量调度策略。</p>
<p>并将以上方法实现为一个工具，叫做LeoFuzz，并评估其在crash reproduction，true positive verification，vulnerability exposure的表现。实验结果表示，LeoFuzz优于现有的六个模糊测试，QYSM，AFLGo，Lolly，Berry，Beacon和WindRanger。而且，在真实程序中发现了23个新的漏洞，其中11个获取了CVE ID。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>一个程序中通常会有多个漏洞存在。这种情况要用定向模糊测试找的话，有两种方法。</p>
<ul>
<li>开n个fuzzing的进程，然后给一个target，让定向模糊测试跑。</li>
<li>给多个目标，直接给模糊测试跑。</li>
</ul>
<p>本文的目标是增强第二种方法的有效性和效率。</p>
<p>现有定向模糊测试在处理多目标的时候，表现很差，原因在于两点：粗粒度的能量调度和静态化的状态划分。</p>
<p>能量调度策略是用来控制种子变异的次数。在DGF中，调度策略会逐渐添加能量到距离目标更近的种子上，能够更快地触发目标位置。比如，AFLGo，给更多的能量到离所有目标近的种子，虽然这种策略使得AFLGo忽视了局部最优。</p>
<p>问题1：为了覆盖更多的目标，就会追求对所有target的全局最优，而忽视了对于一些target的局部最优，从而导致一些目标很难到达。设计一种合理的能量调度算法，能够在有限的时间到达更多的target又是另外一个问题。</p>
<p>DGF分为两个阶段运行，探索（exploration）和利用（exploitation）。在探索阶段，fuzzer通过种子变异来尽可能获取更大的代码覆盖率。在利用阶段，fuzzer变异并执行种子来使得种子离目标位置更近。比如，AFLGo从探索阶段开始，随机变异初始种子去生成新的输入，来增加代码覆盖率。在利用阶段生成更多新的输入离目标更近。然而，区分利用和探索的阶段是静态确定的。比如说，AFLGo设定用20小时去探索，然后用4小时去利用。这种静态切换的策略忽视了动态的运行信息，并且会影响AFLGo的性能。</p>
<p>问题2：更少的探索会提供更少的覆盖率信息用来利用，使得在利用阶段更难生成高质量的种子。然而，过多的探索会消耗过多的资源，而且减少了利用的时间，缺少了定向性。因此，怎么动态地平衡二者的关系是一个挑战。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h3><p>静态分析分为两个部分：目标序列生成以及静态插桩。</p>
<p>目标序列生成主要是给定一个target，生成target必经的序列。然后再由静态插桩，将对至少有一个target的基本块进行插桩。这样在运行时不仅可以获取覆盖率信息，也可以获取执行轨迹信息。</p>
<p>目标序列生成类似Berry和Lolly。都是基于Dominator Tree生成。</p>
<p>比如下面这个例子，给定目标点g，先通过调用图的支配树找到到达点g所在函数的必经调用链，然后在函数G里，再找必经基本块。最后串起来是：main1-&gt;A1-&gt;entry-&gt;a-&gt;f-&gt;g</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20221012162057637.png" alt="image-20221012162057637"></p>
<h3 id="动态分析"><a href="#动态分析" class="headerlink" title="动态分析"></a>动态分析</h3><p>总体算法思路挺清晰易懂的。首先根据stageCoord函数先确定是exploration还是exploitation。如果是exploration就从覆盖率队列取种子，反之从另外一个队列取种子。然后给种子赋予能量。在执行种子的过程中，如果发生崩溃，就送到崩溃种子集合里。反之，检查两个覆盖率的情况。如果目标序列的覆盖率增加了，就将变异后的种子加入到DQ序列，并更新dsc，csc和ndc的值。如果代码覆盖率增加了，就将变异后的种子加到CQ序列中，更新csc，ndc的值。如果都没增加就增加ndc的值。直到时间结束。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20221013152909333.png" alt="image-20221013152909333"></p>
<p>然后是状态切换的算法，如果是exploration状态，检查下csc&#x2F;(csc+dsc)是否大于某个值，大于就切换到exploitation阶段。csc表示覆盖率队列的长度，dsc表示定向队列的长度。这个条件说明当fuzzer有了足够多的覆盖率信息，就可以切换到利用状态了。如果一开始的话，是不是就直接切换到exploitation阶段了？当然作者马上给出了阶段，将初始的dsc设置为10，以防一开始就切换到exploitation阶段。另外这里的Rate的计算也是动态更新的。rate越大，在探索阶段的时间越大。为了平衡exploration和exploitation，使用下面的公式去更新Rate的值。cdsc&#x2F;根号t的值越大说明在利用阶段产生的种子越多，并且当前的代码覆盖率足够到达目标，需要更快切换到exploitation阶段。另外随着时间的增加，找到定向种子的概率也会变小，所以用epoch参数来调整这个影响。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20221013160648507.png" alt="image-20221013160648507"></p>
<p>如果是exploitation阶段，计算阈值th，如果ndc大于阈值th就切换到exploration状态。阈值的计算是看后两轮的exploitation阶段的ndc的值加起来乘以开根号的epoc再乘以1&#x2F;2.为啥这么算呢？作者认为ndc小于这个阈值的时候，就说明fuzzer的利用能力很弱了，需要切换到exploration阶段发现更多的路径。阈值这么设计是因为找到一个新的定向种子的可能性会在fuzzing的过程中下降，所以需要在每轮epoc中增加阈值的大小，来保证fuzzer能够在利用阶段更久一些。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20221013153857719.png" alt="stageCoord"></p>
<p>接下来是介绍种子能力调度的模块。</p>
<p>对于一个种子和多个目标来说，LeoFuzz会在静态分析阶段生成所有的目标序列，并且在fuzzing阶段获取种子。文中考虑了三类种子和目标序列的关系。</p>
<p>目标序列的优先级。能够说明目标序列和其他序列的<strong>相似性</strong>。LCS表示两个序列的最长公共子串。Max返回两个序列的最大长度。优先级越高表示有更多的机会可以通过变异到达多个目标。<strong>他的优先级是根据序列的简单程度来判断的。</strong></p>
<p>目标序列的最大覆盖率。它表示任何执行轨迹的最大覆盖率。能够估计覆盖目标序列的难度，并且随着动态分析进行更新。</p>
<p>种子序列覆盖率。它用来衡量种子执行轨迹和目标序列的相似度。</p>
<p>基于上面三个指标，合成为一个指标CF，来用于后续的种子能量分配。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20221013170954236.png" alt="image-20221013170954236"></p>
<p>同样也是用模拟退火算法来寻找CF的全局最优。后面的思路基本类似AFLGo。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20221013171101399.png" alt="image-20221013171101399"></p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20221013171109788.png" alt="image-20221013171109788"></p>
<p>另外，由于模糊测试通过变异难以到达较深的程序路径。为了解决这个问题，同样引入了concolic executor。利用concolic executor跑一遍种子，然后生成新的种子。种子主要是从DQ队列中取。</p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>主要讨论这六个问题：</p>
<ul>
<li><p>Leofuzz在一个target的时候效果如何？</p>
<ul>
<li>连单一的target的效果都好。这个target怎么设定的，存在疑惑。</li>
</ul>
</li>
<li><p>在crash reproduction这个应用效果如何？</p>
</li>
<li><p>多个target的时候效果咋样？</p>
<ul>
<li>多个target怎么来的没说。</li>
</ul>
</li>
<li><p>true positive的验证效果如何？</p>
<ul>
<li>用的libming 来做实验。target来源于clang static analyzer</li>
<li>基本时间在一个小时以内。只验证了libming？不知道其他的效果如何？</li>
</ul>
</li>
<li><p>能否发现未知漏洞</p>
<ul>
<li>在cxxfilt 2.36，SWFTools 和 libredwg里发现了11个0 day漏洞。</li>
</ul>
</li>
<li><p>哪些设计影响了最后效果?</p>
</li>
</ul>
<p>主要考虑了四个决策对最后结果的影响。</p>
<ul>
<li>target sequence enhancement</li>
<li>exploration exploitation coordination</li>
<li>fine-grained energy scheduling strategy </li>
<li>concolic execution</li>
</ul>
<p>最后贡献度排名是：MES&gt;CEE&gt;target sequence enhancement &gt; concolic execution</p>
<p>concolic execution提升小反而是没想到的。</p>
<h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>AFLGo是第一个定向模糊测试，它的模拟退火能量调度策略会分配更多能量给离目标位置近的种子。基于AFLGo，Hawkeye支持间接调用，并调整了AFLGo的种子选择，能量调度和变异策略。然而AFLGo和Hawkeye都不支持多目标。同样，基于AFLGo，RDFuzz通过结合到目标点的距离以及路径的频率，并使用静态调度模块来协调exploration和exploitation。</p>
<p>也有一些定向模糊测试使用sanitizer的输出来指导fuzzing。SAVIOR使用了UBSan的输出作为目标点。然后基于种子遇到的新分支和在这些分支上的目标点和求解分支约束的难易度来计算种子的能量。ParmeSan利用多个sanitizers报告的error和warning来作为目标点，并且用种子到目标的距离来指导模糊测试。LeoFuzz也可以使用sanitizers的结果作为target。</p>
<p>另外一些定向模糊测试使用数据流分析。CAFL目标是满足一序列的约束条件，然后优先选择最适合这些条件的种子。它定义了一个单一目标点的约束条件以及一些可选的数据条件。CAFL需要额外的信息源，比如内存检测器的crash dump或者补丁的changelogs。WindRanger使用基本块的deviation和他们的数据流信息来计算种子的距离。他也会动态的在exploration和exploitation切换。Beacon使用静态的方法提前识别出不可达的路径。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从这篇文章看得出来，作者用了很多他自己以前工作的东西。比如dominator tree，LCS，混合测试等等。</p>
<p>实验做的很充分。还发现了许多0day漏洞。从时间来看，在2021年就挖到了不少cve，22年的6月投稿TDSC。看得出来工作量蛮大的。</p>
<p>作者前面几篇发的论文berry和lolly也用在本次的对比试验了。作者这个技术路线还是挺清晰的，值得学习。</p>
]]></content>
      <tags>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title>【论文笔记】Sequence Coverage Directed Greybox Fuzzing</title>
    <url>/2022/02/15/Sequence%20Coverage%20Directed%20Greybox%20Fuzzing/</url>
    <content><![CDATA[<h1 id="Sequence-Coverage-Directed-Greybox-Fuzzing"><a href="#Sequence-Coverage-Directed-Greybox-Fuzzing" class="headerlink" title="Sequence Coverage Directed Greybox Fuzzing"></a>Sequence Coverage Directed Greybox Fuzzing</h1><blockquote>
<p>本文介绍一篇来自CCF B类会议 ICPC 2019的关于定向模糊测试的文章。</p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>现有的定向模糊测试不足够高效。定向符号执行，比如BugRedux，花很多时间在很重的程序分析和约束求解上。定向模糊测试，比如AFLGo，在运行时做得很好。但是插桩过程中的距离计算花费了很大的开销。</p>
<p>这篇文章提出了一种序列覆盖率的定向模糊测试，能够按顺序到达目标行。并且和AFLGo和BugRedux这两个工具进行了对比实验。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>fuzzing是一种高效的挖漏洞的技术。但是fuzzing会花费很多时间在和bug不相关的代码上。因此，有定向fuzzing这样的技术来专门针对某块代码区域进行测试。</p>
<p>然而目前大多数的定向fuzzer都是基于符号执行的白盒fuzzer。他们把可达问题转换为迭代式的约束求解问题，花费了很多运行时间在重量级的程序分析和约束求解上。因此虽然有效，但是不高效。</p>
<p>灰盒fuzzer，像AFLGo这样的，把可达性问题转化为优化问题。然而，AFLGo为了提高运行时的效率，把很多程序分析都放在了插桩部分，导致插桩部分比较耗时。如果用户的计算资源比较有限，这个开销就会成为问题。</p>
<p>所以，本文提出了一种轻量级的定向fuzzing技术。包括在插桩部分也更加的轻量级。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>由于文中用了很多简称，所以先记录于此：</p>
<ul>
<li>SS：statement sequence（语句序列）</li>
<li>BLS：basic block location sequence（转化为基本块位置序列）</li>
<li>TBBET：target basic block execution trace</li>
</ul>
<p>在每个目标基本块的入口，会添加如下指令：</p>
<ul>
<li>获取共享内存的指针M</li>
<li>读取M0的值，并为其加1，i.e. i &#x3D; i + 1</li>
<li>将当前基本块的ID存入Mi</li>
<li>把第二步得到的值再存入M0, i.e. M0&#x3D;i</li>
</ul>
<p>在fuzz的过程中，当种子探索到目标基本块的时候，插桩的代码就会执行，因此，基本块的Trace就会被存储在共享内存中。</p>
<p>fuzzing的算法如下，主要分为两个部分，计算序列覆盖率（2-13行）和能量调度（14-22行）。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20220131164840556.png" alt="image-20220131164840556"></p>
<p>计算序列覆盖率的算法如下，它的主要思想是要找到种子执行的Trace和预设的序列的最长公共子序列。</p>
<p>其中变量maxSClen记录最大的序列覆盖率的长度。</p>
<p>遍历动态执行的trace的每个基本块ti，如果ti等于当前的目标，curSClen的值加一。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20220131164900925.png" alt="image-20220131164900925"></p>
<p>举个例子，BLS：&lt;b0,b1,b3,b5&gt; , TBBET：&lt;b0,b5,b0,b1,b5&gt;，上面计算序列覆盖率的算法其实就是找最长公共子序列。最后的序列覆盖率为3&#x2F;4，3为TBBET按顺序覆盖BLS基本块的数目，4为BLS集合中的基本块数目。</p>
<p>种子能量调度：用的模拟退火算法来做</p>
<p>温度T初始值为T0 &#x3D; 1，然后以指数降温。</p>
<p>$T &#x3D; T_{0} \times \alpha^{k} $ </p>
<p>其中α是在0.8到0.99之间的常数。k是温度循环。温度的阈值Tk被设为0.05。也就是说，如果Tk大于0.05，属于exploration stage，也就是探索阶段。这一阶段SCDF会去尽可能地生成更多随机的输入。反之，就是进入exploitation stage，会去尽可能地生成更多高序列覆盖率的输入。</p>
<p>由于fuzzing的限制是时间，时间会被用来调整温度循环k：</p>
<p>$k&#x2F;k_{x} &#x3D; t&#x2F;t_{x}$</p>
<p>其中kx和tx是当温度到达了Tk的温度循环和时间。</p>
<p>然后根据k的关系，可以推导出温度T和时间的关系。</p>
<p>$T_{k}&#x3D;0.05&#x3D;\alpha^{k_{x}}$</p>
<p>$T&#x3D;\alpha^{k}&#x3D;\alpha^{\frac{t}{t_{x}} \times \frac{log(0.05)}{log(\alpha)}}&#x3D;20^{-\frac{t}{t^{x}}}$</p>
<p>和AFLGo的模拟退火算法类似，给定一个种子s，它的序列覆盖率是seqcov，那么它覆盖给定行号序列的能力是：</p>
<p>$capcov &#x3D; seqcov * (1 - T) + 0.5 * T$</p>
<p>最后的能量就为：</p>
<p>$Lenergy &#x3D; energy * 2.0^{(capcov-0.2)*10}$</p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>用clang static analyzer跑了下libming 0.4.8的几个CVE。</p>
<p>实验部分主要涉及三个方面的应用效果，并且和AFLGo和BugRedux这两个工具进行了对比：</p>
<ul>
<li>True positives verification</li>
<li>Crash reproduction</li>
<li>Bug exposure</li>
</ul>
<h3 id="True-positives-verification"><a href="#True-positives-verification" class="headerlink" title="True positives verification"></a>True positives verification</h3><p>在软件开发周期里，开发者和测试人员通常都会用分析工具来发现bugs或者漏洞。静态分析是一种很热门的分析技术来找到结构化的错误和安全漏洞。由于静态分析并不执行程序，所以会有比较高的误报，需要人工去验证分析结果。由于定向执行的特性，定向模糊测试技术可以用来自动验证bugs。具体来说，静态分析器产生的结果都是一些程序里潜在的bugs或者漏洞，这些可以转化为定向模糊测试的目标语句，然后用定向fuzzing技术去生成测试样例去验证。</p>
<p>作者实验使用了libming 0.4.8，一个处理SWF文件的C语言库。然后用clang static analyzer（CSA）去分析libming，获取一些目标行号。然后把这些行号送给AFLGo和Lolly。在实验过程中，CSA的结果没用特意的去过滤，所以静态器给的结果里可能会有很多误报和不可达路径的结果。</p>
<p>为了评估两个fuzzer的有效性，使用相同的目标行号喂给定向fuzzer，然后看能否触发相同的CVE漏洞。并且统计两个fuzzer的插桩时间和运行时间，重复实验二十次，取平均值。</p>
<p>实验用的CVE如下：</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20220215172511929.png" alt="image-20220215172511929"></p>
<p>插桩时间的话，AFLGo用了近2个小时，而lolly只用了40多秒，AFL只需要39秒。</p>
<p>运行过程中，设定运行5个小时。结果如下表。TTE表示发现给定漏洞所需的时间。Factor是AFLGo的TTE与lolly的比值。A12是衡量随机算法的一个指标。给定一个性能衡量的指标（比如TTE），A12能够测量lolly得到好的TTE的值的概率比AFLGo高。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20220215173946168.png" alt="image-20220215173946168"></p>
<h3 id="Crash-reproduction"><a href="#Crash-reproduction" class="headerlink" title="Crash reproduction"></a>Crash reproduction</h3><p>现在软件系统里因为各种原因可能有潜在的bug或者漏洞。当用户使用软件遇到崩溃时，可以提假崩溃报告到开发者。一个崩溃报告通常包含崩溃的信息，比如memory dumps或者调用栈。定向模糊测试可以利用这些信息来复现crash。这里将lolly和AFLGo和BugRedux进行对比。BugRedux是基于KLEE实现的白盒定向fuzzer。给定一个程序的目标行号，BugRedux可以生成测试样例，按顺序执行这些目标。</p>
<p>这个实验用的测试程序都是BugRedux使用的。设定运行时间为24h，如果工具能够复现bug，就标记为✔，反之就标记为×。sed.fault1这个crash需要同时fuzz两个输入文件，这是AFLGo和Lolly都做不到的。其他的测试程序里，AFLGo和lolly都可以复现。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20220216105130990.png" alt="image-20220216105130990"></p>
<p>然后进一步对比了AFLGo和Lolly的插桩时间和运行时间。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20220216133747917.png" alt="image-20220216133747917"></p>
<h3 id="Bug-exposure"><a href="#Bug-exposure" class="headerlink" title="Bug exposure"></a>Bug exposure</h3><p>然后用clang去分析Binutils，libxml和libming这些软件。发现了如下漏洞。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20220216134043734.png" alt="image-20220216134043734"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>文章是一种相比AFLGo更轻量级的定向模糊测试，节省了更多的插桩开销时间。同时也考虑了给定行号的顺序关系。后续作者在此基础上又进行了优化，文章名为：Sequence Directed Hybrid Fuzzing</p>
]]></content>
      <tags>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title>【论文笔记】SieveFuzz</title>
    <url>/2022/01/08/SieveFuzz/</url>
    <content><![CDATA[<h1 id="One-Fuzz-Doesn’t-Fit-All-Optimizing-Directed-Fuzzing-via-Target-tailored-Program-State-Restriction"><a href="#One-Fuzz-Doesn’t-Fit-All-Optimizing-Directed-Fuzzing-via-Target-tailored-Program-State-Restriction" class="headerlink" title="One Fuzz Doesn’t Fit All: Optimizing Directed Fuzzing via Target-tailored Program State Restriction"></a>One Fuzz Doesn’t Fit All: Optimizing Directed Fuzzing via Target-tailored Program State Restriction</h1><h2 id="论文基本信息"><a href="#论文基本信息" class="headerlink" title="论文基本信息"></a>论文基本信息</h2><p>发表会议或期刊（简称，CCF级别）：ACSAC 2022<br>论文标题（论文简称）：One Fuzz Doesn’t Fit All: Optimizing Directed Fuzzing via Target-tailored Program State Restriction<br>论文作者所在团队：Hexhive<br>论文一句话概述：论文提出XX方法，解决了XX问题。<br>论文实验情况：实验工具（是否开源），实验测试集（是否开源），实验环境，实验规模，简要过程</p>
<p>开源于：<a href="https://github.com/HexHive/SieveFuzz">https://github.com/HexHive/SieveFuzz</a></p>
<h2 id="论文概述"><a href="#论文概述" class="headerlink" title="论文概述"></a>论文概述</h2><p>众所周知，fuzzing是发现软件漏洞的一种实用技术。然而，有时候，我们只需要关注特定的代码区域有没有漏洞，比如漏洞复现，补丁或者回归测试。这种需求催生了定向模糊测试。给定一些目标位置（行号），定向模糊测试通过距离最小化策略来让fuzzing往这些地方探索。距离最小化策略是找到离目标近的测试样例，然后随机地变异这些测试样例。然而，这个策略被应用到所有的测试样例，不管样例是否到达了目标，这就会导致浪费很多时间计算没有到达目标的测试样例的距离。要加速定向模糊测试就需要对目标可达的路径进行优先级排序。</p>
<p>因此，本文提出了tripwiring（绊绳，一种陷阱，可以让路过的东西摔倒），一种轻量级的技术过滤不会到达目标的路径。通过限制模糊测试探索只会到达目标的路径，可以减小模糊测试的噪声，从而减小了插桩和距离最小化策略的开销，能够提升定向模糊测试器高达99x的测试样例的吞吐量。</p>
<p>实验评估方面，与AFLGo，Beacon和AFL++进行了对比，在9个benchmark上触发的漏洞要比这些工具多47%，也快117%。</p>
<h2 id="研究背景"><a href="#研究背景" class="headerlink" title="研究背景"></a>研究背景</h2><p>现有的定向模糊测试使用距离最小化策略来让fuzzing探索预定义的目标位置。为了实现定向性，距离最小化策略计算每个生成的测试样例到目标位置的距离。然而距离测量是在运行时，并且是对所有种子实施的。而大多数的种子并不会到达目标，就会引入过多的开销。</p>
<p>而且，距离最小化策略并不适合那些很容易到达的目标。对于这些容易到达的目标，距离最小化的开销很大。没必要对无法到达目标的路径进行分析。</p>
<h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>文章主要介绍了两类工作，一个是定向模糊测试，另一个是提高fuzzing性能的。</p>
<p>定向模糊测试这块提到了AFLGO，Hawkeye，ParmeSan，UAFuzz，UAFL，BEACON。</p>
<p>提高fuzzing性能的提到了AFL-Dyninst，AFL-QEMU，RetroWrite，ZAFL。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20230108173457057.png" alt="image-20230108173457057"></p>
<p>宏观层次上，用传统的控制流和路径检测方法识别出到达目标位置的路径，然后修改覆盖率导向的模糊测试让其只探索这些区域，从而实现定向性。</p>
<p>文章的核心思想是认为定向模糊测试浪费过多的时间在目标不可到达的路径上，所以可以先发制人地终止模糊测试探索目标不可达的区域。这么做有两点好处：</p>
<ul>
<li>fuzzer里超过90%的运行时间就不会花在计算代码覆盖率和目标距离上。</li>
<li>过滤掉这些路径，fuzzer就不会浪费资源在处理这些测试样例上。</li>
</ul>
<h3 id="识别不可达区域"><a href="#识别不可达区域" class="headerlink" title="识别不可达区域"></a>识别不可达区域</h3><p>识别不可达区域的算法如下，首先用目标位置的入口结点来初始化worklist，同时allow list也初始化为空集。然后，对于worklist中的每个元素，做如下操作：</p>
<ul>
<li>在过程间控制流图上，找到每个节点的来边</li>
<li>对于每条边，检查它的源和对应于过程间控制流图上的节点</li>
<li>使用调用图检查从源能否到目标，如果可以，就把源加在allow list里，对应节点加在worklist里。</li>
</ul>
<p>所有在allow list外的节点就会被判定为不必要的。由于过程间控制流图对上下文不敏感，我们的分析可能会多包含一些目标相关的代码区域。为了缓解这个问题，整合了函数可达性分析的结果。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20230108185845593.png" alt="image-20230108185845593"></p>
<p>同时，由于使用静态分析来生成ICFG和CG，另一个挑战是处理间接跳转。求解间接跳转的静态方法有指向分析和值集分析，但是这种静态的方法会over-approximate候选的目标。从而不能保证fuzzing的定向性。</p>
<p>为了缓解这个问题，文章用每个新覆盖的间接分支来更新调用图。有了新信息后，再重新用上面的分析方法来更新可达的区域。虽然这种重分析技术会增加运行时开销，但是带来的好处是覆盖率的指数下降，所以不会有很明显的性能下降。</p>
<p>虽然是动态解决间接调用问题的，目标位置在一开始的可达性分析里可能会被忽略。然而，作者观察到用其他模糊测试器生成种子的trace来进行分析就够了。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>基于AFL++实现。为了实现按需的可达性分析，实现了fuzzer和分析模块的client-server的通信机制。静态分析基于SVF框架。</p>
<p>总体框架可以用一个状态机来表示。</p>
<p>INIT：一开始，确定target是否在初始的ICFG和CG上可达。如果是不可达，有可能静态没有识别到一些间接跳转的。因此转到EXP状态去探索。利用EXP过程跑的动态信息来更新ICFG和CG。不过要尽可能避免EXP过程，所以一开始会利用初始种子来更新这些间接跳转。</p>
<p>EXP：如果目标是不可达的，就使用非定向，non-tripwired的模糊测试来多样化可选的种子。一旦发现有一条路径可以到达目标，就退出这个阶段，跳到FUZZ阶段。</p>
<p>FUZZ：一旦确定target是可达的，tripwired-directed fuzzing就开始了。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20230108195707674.png" alt="image-20230108195707674"></p>
<p>为了随时更新间接跳转，作者实现了按需的可达性分析。也就是引入了通信机制，一旦发现新的间接边，就暂停fuzzer，等待静态分析模块反馈结果。不过这个切换实际运行时并不多。</p>
<p>提前终止部分的实现是：分配给每个代码区域一个唯一的数字ID，然后用ID去hook每个区域调用运行库的开始。然后把这个库链接到被插桩的程序，利用它来强制终止执行。</p>
<p>同时也会维护一个动态的bitmap，每个bit和每个ID映射。如果bit是unset，和这个bit相对应的函数就不会被执行。间接跳转追踪的部分，对所有间接跳转分支进行插桩，去获取这些边的目的地。</p>
<h2 id="实验结果及分析"><a href="#实验结果及分析" class="headerlink" title="实验结果及分析"></a>实验结果及分析</h2><p>主要回答这三个问题：</p>
<ul>
<li>RQ1：Is tripwiring effective and fast at restricting fuzzing-reachable search space?,</li>
<li>RQ2：Do the benefits of tripwiring improve directed fuzzing effectiveness and speed?</li>
<li>RQ3：Are there properties that make a target location well suited to tripwiring?</li>
</ul>
<p>对于RQ1，平均消除了29%的空间。这让我有点意外，比我想象中的少很多。表格中也给出了初始分析的时间和重分析的时间，开销是比较小的。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20230109195140486.png" alt="image-20230109195140486"></p>
<p>对于RQ2，触发漏洞的时间比AFLGO快3.49x，比AFL++快8.36x，比Beacon快2.82x</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20230109195933269.png" alt="image-20230109195933269"></p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20230109200808145.png" alt="image-20230109200808145"></p>
<p>对于RQ3，作者得出两个结论：</p>
<ul>
<li>可以用“不能到达目标位置的代码数量”来识别目标是否disjoint。也就是脱节。</li>
<li>对于这类脱节的目标，用文章的方法要比距离最小化的方法好。</li>
</ul>
<h2 id="自己的感受"><a href="#自己的感受" class="headerlink" title="自己的感受"></a>自己的感受</h2><p>这篇文章的思路和Beacon有些相似，但是，是通过动态的方法解决的。</p>
<p>而且实现上有几个点挺有意思的。比如，动态方法解决间接调用追踪的问题，通过链接库来让程序提前终止等等。</p>
<p>并且发现开源的仓库给的脚本特别详细，所有的数据应该是都开源了。有机会看一看他的仓库。</p>
<p>最后就是这篇文章写作上用词用得比较巧，有很多表达是值得收藏的。</p>
]]></content>
      <tags>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title>【论文笔记】Sequence Coverage Directed Greybox Fuzzing</title>
    <url>/2022/02/16/Sequence%20Directed%20Hybrid%20Fuzzing/</url>
    <content><![CDATA[<h1 id="Sequence-Directed-Hybrid-Fuzzing"><a href="#Sequence-Directed-Hybrid-Fuzzing" class="headerlink" title="Sequence Directed Hybrid Fuzzing"></a>Sequence Directed Hybrid Fuzzing</h1><p>这篇文章发表于CCF B类会议SANER 2020，是ICPC 19年一篇工作的改进版Sequence coverage directed greybox fuzzing</p>
<p>主要的变化是原来是单纯的fuzz，现在是hybird Fuzz，也就是加入了符号执行来作为辅助。</p>
<p>这篇工作要解决的问题是：现有的定向模糊测试没有在effectness和efficiency上达到很好的平衡，也很难基于随机变异来覆盖复杂的路径。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>文章主要是在能量调度算法和种子选择策略做了修改。能量调度算法是根据目标序列和种子执行轨迹的相似度进行比较。种子选择策略在lolly基础上，又多考虑了到达目标的路径上的必要点。变异输入部分再结合concolic execution来高效生成覆盖复杂条件的输入。</p>
<p>文章的总体框架如下所示，分为静态分析和动态分析两个部分。</p>
<p>静态分析首先把目标序列和源码的行号转化为基本块，并且基于dominant tree analysis求出ETS。其中ETS表示的是enhanced target sequence，意思是目标序列和到达目标序列的必要节点的结合。然后插桩主要是为了在运行时获得分支覆盖率和目标执行轨迹的信息。</p>
<p>动态分析部分，fuzzer的输入是插桩后的二进制和ETS，然后fuzz的过程时，把种子放在三种级别的队列中，分别是L1，L2，L3，表示高优先级，普通优先级，低优先级。Concolic Executor的输入是测试的二进制（PUT）和L1级别的种子，并且把新生成的种子放在L2级别。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20220216172449097.png" alt="image-20220216172449097"></p>
<h3 id="Static-Analysis"><a href="#Static-Analysis" class="headerlink" title="Static Analysis"></a>Static Analysis</h3><p>为了支持细粒度的调度种子，文章考虑了目标序列的覆盖率以及他们的执行上下文（也就是到达目标序列的必要节点）。执行上下文获取的算法如下图所示：</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20220217105107067.png" alt="image-20220217105107067"></p>
<p>在控制流图中，如果到达节点n的每条路径都需要经过节点d，那么就叫节点d为节点n的支配节点。如果树上的每个节点只支配自身及其子节点，就叫这个树为支配树。</p>
<p>上面的算法里，n0是entry node，N是所有基本块的集合。对于一个基本块n，他的支配节点是节点n所有前驱节点的支配节点的交集。所以，一开始的时候，对于任意一个节点n，先将他的支配节点的集合设为N。然后再迭代式地移除不属于节点n的支配节点（5-9行）。最后13行-15行是去获取属于目标序列（Target Sequence）的必要节点。</p>
<p>接下来是插桩部分，除了插桩获取覆盖率信息外，SDHF也对ETS的基本块进行插桩，来获取目标执行轨迹TET。覆盖率信息和TET和ETS的相似度将被用于确定种子的优先级。</p>
<p>比如下面的例子，种子的执行轨迹是“aegabdfg”，由静态分析得到的ETS是abcg，通过插桩得到的TET是ababg。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20220217110654254.png" alt="image-20220217110654254"></p>
<h3 id="dynamic-analysis"><a href="#dynamic-analysis" class="headerlink" title="dynamic analysis"></a>dynamic analysis</h3><p>动态分析部分主要是fuzzer和concolic executor的交互。</p>
<p><strong>1）fuzzing process</strong></p>
<p>fuzz的总的流程如下所示。首先从种子队列S中取出一个种子s，并且给种子赋予能量p。种子的能量决定了变异这个种子的时间。然后，fuzzer对种子进行变异，并且生成新的种子s‘，如果s’产生了crash，就会把这个种子放在Sx集合中。对于每个新生成的种子s‘，都会去计算种子执行轨迹与ETS的相似度sim以及是否有增加覆盖率cov。如果相似度大于某个阈值d并且有新增覆盖率，则把种子加入L1优先级队列，如果相似度大于d，但没有新增覆盖率，则要放到L2中。如果种子相似度没有大于阈值也没有新增覆盖率，就放到L3。持续这个过程直到超时或者手动中止。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20220217114303629.png" alt="image-20220217114303629"></p>
<p><strong>2）concolic execution</strong></p>
<p>concolic execution是fuzzing过程的一个辅助手段，它以部分匹配的种子作为输入，来生成更高相似度的种子。因为fuzzer是依靠随机变异来生成种子，即使fuzzer生成了高相似度的种子，也不能确定新生成的种子接近了目标序列。concolic execution能够获取种子执行的路径并且生成执行特定路径的输入。</p>
<p>这部分的算法如下图所示。首先执行给定的种子S，获得种子S执行的路径Trace。然后遍历路径Trace上的基本块，根据最大匹配前置路径，找到转换点SP的基本块，获取转换点基本块另一个没执行过的子节点的约束，生成新的种子。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20220217185724959.png" alt="image-20220217185724959"></p>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>在LAVA-M上与QSYM比较发现漏洞效率，TTE表示发现漏洞的时间。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20220217191920235.png" alt="image-20220217191920235"></p>
<p>和BugRedux，AFLGo比较复现漏洞的有效性。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20220217192202079.png" alt="image-20220217192202079"></p>
<p>与Lolly比<em>True Positives Verifification</em>的能力</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20220217192408062.png" alt="image-20220217192408062"></p>
<p>最后再用工具挖到了几个真实的漏洞：</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20220217192519751.png" alt="image-20220217192519751"></p>
]]></content>
      <tags>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title>【论文笔记】WindRanger:A Directed Greybox Fuzzer driven by Deviation Basic Blocks</title>
    <url>/2022/10/17/WindRanger%20A%20Directed%20Greybox%20Fuzzer%20driven%20by%20Deviation%20Basic%20Blocks/</url>
    <content><![CDATA[<h1 id="WindRanger-A-Directed-Greybox-Fuzzer-driven-by-Deviation-Basic-Blocks"><a href="#WindRanger-A-Directed-Greybox-Fuzzer-driven-by-Deviation-Basic-Blocks" class="headerlink" title="WindRanger: A Directed Greybox Fuzzer driven by Deviation Basic Blocks"></a>WindRanger: A Directed Greybox Fuzzer driven by Deviation Basic Blocks</h1><h2 id="论文基本信息"><a href="#论文基本信息" class="headerlink" title="论文基本信息"></a>论文基本信息</h2><p>发表年份：2022<br>发表会议或期刊（简称，CCF级别）：CCF A类会议 ICSE<br>论文标题（论文简称）：WindRanger: A Directed Greybox Fuzzer driven by Deviation Basic Blocks<br>论文一句话概述：提出了deviation basic block的概念，并利用它构造定向模糊测试。</p>
<p>工具开源于：<a href="https://sites.google.com/view/windranger-directed-fuzzing/">https://sites.google.com/view/windranger-directed-fuzzing/</a></p>
<p>实验用的数据是unibench，开源于：</p>
<h2 id="论文概述"><a href="#论文概述" class="headerlink" title="论文概述"></a>论文概述</h2><p>定向模糊测试是一种安全测试技术，致力于探索程序中的特定的位置。为了获取定向性，DGF优先选择那些执行路径离目标位置更近的种子。因此，评估种子执行路径到目标位置的距离对于定向模糊测试来说很重要。第一个定向灰盒测试器，AFLGo使用静态分析来计算基本块距离，并且在执行的过程中累积执行过基本块的距离来计算种子离目标的距离。顺延AFLGo，后续的定向模糊测试都使用所有的基本块计算距离，并且只考虑了控制流信息。然而，不是所有的基本块都是同等重要的，就有一些基本块（deviation basic block）的执行路径已经开始偏离目标位置。</p>
<p>文章提出了一种名为WindRanger的技术，利用了deviation basic block来构造定向灰盒测试。为了识别deviation basic block，WindRanger不仅应用了静态可达性分析，也使用了动态过滤。为了构建定向模糊测试，WindRanger使用deviation basic block和他们相关的数据流信息来用于种子的距离计算，变异，种子选择，explore和exploit的切换。在3个数据集上使用了29个程序进行评估，实验结果表明WindRanger由于AFLGO，AFL和FairFuzz。而且还发现了1个在ffmpeg的0day漏洞。</p>
<h2 id="研究背景"><a href="#研究背景" class="headerlink" title="研究背景"></a>研究背景</h2><p>问题是什么？现有的定向模糊测试计算距离的时候考虑了执行路径上的所有基本块，而且只考虑了控制流信息。然而，不是所有的基本块都是相同重要的，因为有一些开始偏离目标位置的基本块要另作考虑。</p>
<p>意义是什么？能够更快到达目标，并泄露漏洞。</p>
<h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>相关工作分为三类：定向符号执行，定向灰盒测试，覆盖率导向灰盒测试。</p>
<p>定向符号执行使用协同程序信息来获取定向性，相比通用符号执行，能够有效地测试程序指定位置。然而，定向符号执行在真实程序中效果不好，主要是由于符号执行有严重的路径爆炸问题。</p>
<p>定向灰盒测试，AFLGo是第一个。计算种子的trace到目标的距离，然后应用到能量调度模块，对离的近的种子赋予更大的能量（变异更多次）。Hawkeye在AFLGo的基础上进行改进，主要改了三个部分，距离增强的能量调度，种子选择，选择性的变异。AFLGo和Hawkeye把所有的基本块都考虑进来来计算距离。WindRanger侧重于那些阻止输入到达目标位置的基本块，来提高定向模糊测试的效率。另外，FuzzGuard利用深度学习来过滤不能到达目标的输入。</p>
<p>此外，还有一些工作应用定向模糊测试到不同类型的目标点。Leopard使用程序指标来识别程序中的漏洞代码，并把他们设定为目标位置。Parmsan通过sanitizer插桩的位置来作为目标位置。Parmasan基于动态构造的CFG来计算距离。CAFL利用目标位置的顺序信息和数据条件来加强发现目标崩溃的能力。</p>
<p>覆盖率引导的灰盒模糊测试（CGF）致力于让模糊测试覆盖更多的代码。AFL是经典的CGF，使用覆盖率来引导种子进化。为了提高CGF的覆盖率，一个研究方向是帮助CGF求解程序中的条件约束。混合测试（Hybrid fuzzing）结合CGF和符号执行去加强CGF里的约束求解能力。几个其他的工作采用轻量化的方法来帮助约束求解。Steelix使用轻量的静态分析和二进制插桩来获取比较过程的信息，能够帮助CGF探索那些被魔法字节比较的路径。Angora使用梯度下降的输入搜索来求解约束。Greyone使用污点分析和数据流特征来指导fuzzing的进化。FairFuzz识别并标记那些影响输入覆盖稀有分支的字节。除了这些针对分支的研究，也有一些工作优化种子调度，检查特定类型的漏洞，或者自动生成fuzz的harness。虽然，这些工作和windranger的目标不一致，但windranger也会从这些技术中受益（比如约束求解技术）</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>先看一个motivation example来了解deviation  basic block（DBB）的基本原理。DBB实际上就是开始偏离目标点的那个基本块。比如对于种子A来说，21：1这个点就是DBB。因为他的子节点是不可达的。同理，种子B的DBB就是20：2，种子C的是15：1。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20221017144152488.png" alt="image-20221017144152488"></p>
<p>整体框架图如下所示，标有数字的是修改的地方。可以看到改了很多地方。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20221017111305498.png" alt="image-20221017111305498"></p>
<h3 id="DBB识别"><a href="#DBB识别" class="headerlink" title="DBB识别"></a>DBB识别</h3><p>对于WindRanger来说，DBB是很重要的概念。首先，用静态分析找到潜在的DBB。然后，在fuzzing的过程中，WindRanger在执行路径中定位DBB，以及他们和潜在DBB的关系。</p>
<p>潜在DBB的定义如下，简单来说就是满足两个条件：</p>
<ul>
<li>自身到目标存在可达路径</li>
<li>子节点到目标不可达</li>
</ul>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20221017151610389.png" alt="image-20221017151610389"></p>
<p>种子的DBB的定义如下，也是满足两个条件：</p>
<ul>
<li>即在种子路径上，又在潜在DBB集合中的</li>
<li>所有可达的后继节点没有被种子执行</li>
</ul>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20221017152201494.png" alt="image-20221017152201494"></p>
<h3 id="基于估算的污点分析"><a href="#基于估算的污点分析" class="headerlink" title="基于估算的污点分析"></a>基于估算的污点分析</h3><p>使用污点分析的目的是收集数据流信息，可以知道哪些字节会影响给定分支。然后数据流信息就存储在hashmap中，key是分支约束的基本块地址，值是影响分支约束的字节索引。下面的算法，展示了构造这样一个hashmap的过程。</p>
<p>对于一个种子和它的执行路径，首先提取分支约束相关的变量。然后对这些变量进行字节级的变异。有了这些变异后的输入后，windranger检查每个提取的变量是否在变异后发生了变化。如果变量的值变化了，windranger就会更新哈希表，告诉它，这个变异位置的种子会影响变量。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20221017155609272.png" alt="image-20221017155609272"></p>
<h3 id="种子距离计算"><a href="#种子距离计算" class="headerlink" title="种子距离计算"></a>种子距离计算</h3><p>种子计算距离公式如下，简单说就是只计算DBB到目标的距离。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20221017160401908.png" alt="image-20221017160401908"></p>
<p>然而，这还不够，再加上数据流信息，距离的计算公式如下：新增的变量是用来判断通过该约束的难易度。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20221017160917285.png" alt="image-20221017160917285"></p>
<p>难易度公式：有多少字节可以影响约束变量。越多就说明fuzzer需要满足的条件越多，也就越难。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20221017161118586.png" alt="image-20221017161118586"></p>
<h3 id="数据流敏感变异"><a href="#数据流敏感变异" class="headerlink" title="数据流敏感变异"></a>数据流敏感变异</h3><p>如果在exploitation阶段，会将和DBB约束变量相关的输入字节当作是高优先级的字节。</p>
<p>对于一个约束变量和它相关的输入字节，如果输入字节是连续的。Windranger就会检查变量和输入字节是否共享一个值。如果是的话，很有可能输入字节没有经过数据变换。这种情况下，就直接用比较指令的另外一个操作数来替代输入的相关字节。</p>
<h3 id="种子选择"><a href="#种子选择" class="headerlink" title="种子选择"></a>种子选择</h3><p>在exploitation阶段，windranger保留一个高优先级的队列。对于每个DBB，windranger会找到覆盖这个DBB的种子们。然后，windranger基于距离升序将种子排序。并将这些种子放在favored队列，把剩下的种子放在less favored 队列。当要选择下一个种子进行变异的时候，有很高的概率选择favored队列里的。</p>
<p>在exploration阶段，就和普通的CGF一样。选择那些能增加覆盖率的种子。</p>
<p>至于能量调度，就和AFLGO一样，使用的是模拟退火算法，只不过种子距离不一样。</p>
<h3 id="动态切换exploration和exploitation"><a href="#动态切换exploration和exploitation" class="headerlink" title="动态切换exploration和exploitation"></a>动态切换exploration和exploitation</h3><p>虽然DGF的目的是尽可能地快地到达目标，但是DGF仍然需要足够的覆盖率探索去避免陷入局部最优。AFLGO在这方面采取的策略是手动设定时间来区分exploration和exploitation阶段。这种方法需要对不同的程序有着很深的理解。为了解决这个问题，windranger采用动态切换的方式。</p>
<p>具体来说，windranger保留所有的DBB，放在一个全局的集合中。在利用阶段，当集合中的所有DBB都利用的足够了，windranger切换到探索阶段。决定DBB是否利用足够了的指标是DBB被执行了多少次。具体的公式如下，T是fuzzing过程的基本块集合。DDB被执行的次数大于某个常数v乘以基本块里的最小执行次数就够了。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20221017165833265.png" alt="image-20221017165833265"></p>
<p>至于探索阶段切换到利用阶段的话，如果windranger发现了新的DBB，就会切换到利用阶段。</p>
<p>需要注意切换过程只在windranger完成变异后发生。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>主要包含两部分。静态分析器和动态的fuzzer。静态分析器部使用SVF构造过程间控制流图。主要写了900行的C&#x2F;C++代码。动态的fuzzer基于AFL，主要有1000行C代码。</p>
<h2 id="实验结果及分析"><a href="#实验结果及分析" class="headerlink" title="实验结果及分析"></a>实验结果及分析</h2><p>实验方面主要针对以下四个问题：</p>
<ul>
<li>到达目标点的能力有多强？</li>
<li>在复现目标漏洞方面的性能怎么样？</li>
<li>每个组件对总体性能的影响如何？</li>
<li>能否发现真实的漏洞？</li>
</ul>
<h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><p>使用以下三个benchmark：</p>
<ul>
<li>unibench：包含20个真实程序。从数据集中每个程序选4个目标，来评估不同技术到达目标的时间。</li>
<li>AFLGo Test Suite是AFLGo挖到的0-day漏洞。这个数据集被用在很多工作里。</li>
<li>Fuzzer Test Suite是Google提出的数据集。包含几个真实程序和漏洞信息，也广泛用在fuzzing的研究。</li>
</ul>
<p>对比的技术：</p>
<ul>
<li>AFLGo：目前最先进的定向模糊测试技术。其他的hawkeye，fuzzguard没开源。</li>
<li>AFL：经典的覆盖率导向的模糊测试</li>
<li>FairFuzz：选择这个是因为FairFuzz也使用了估计技术来收集污点信息构造fuzzing。</li>
</ul>
<p>评估指标：</p>
<ul>
<li>Time-To-Target：到达目标的时间。这个指标用来评估没有已知漏洞的benchmark上。</li>
<li>Time-To-Exposure：触发目标漏洞的时间。用来评估有漏洞的benchmark。</li>
</ul>
<h3 id="RQ1：到达目标点的能力"><a href="#RQ1：到达目标点的能力" class="headerlink" title="RQ1：到达目标点的能力"></a>RQ1：到达目标点的能力</h3><p>现在暂时没有标准的数据集用来评估DGG到达目标的能力。为此，作者用unibench来构建评估TTT的数据集。</p>
<ul>
<li>对于每个程序，先用AFL跑24h，重复10次，在每次跑的时候，记录每个基本块第一次到达的时间。</li>
<li>统计每个基本块的平均第一次到达时间。</li>
<li>基于平均值，使用四个时间指标来选择基本块。</li>
</ul>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20221017192625095.png" alt="image-20221017192625095"></p>
<h3 id="RQ2-漏洞复现能力"><a href="#RQ2-漏洞复现能力" class="headerlink" title="RQ2 漏洞复现能力"></a>RQ2 漏洞复现能力</h3><p>作者发现在测试binutils的时候，冒出了很多其他的漏洞，但只有7个漏洞是用在实验里的。因此，作者用的是binutils 2.28，然后把对应的cve 反patch回去。就避免人工审计这些crash。这个思路其实被用在很多benchmark的构造上，比如magma，fixreverter。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20221017193237905.png" alt="image-20221017193237905"></p>
<h3 id="RQ3-不同模块的影响"><a href="#RQ3-不同模块的影响" class="headerlink" title="RQ3 不同模块的影响"></a>RQ3 不同模块的影响</h3><p>作者把每个改的地方都关掉了，然后测试了下性能。发现各个模块都提高了10%左右的性能。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20221017194153448.png" alt="image-20221017194153448"></p>
<h2 id="论文总结"><a href="#论文总结" class="headerlink" title="论文总结"></a>论文总结</h2><p>文章的核心思想是deviation basic block，然后围绕其在fuzz上做了一系列的优化。</p>
<h2 id="自己的感受"><a href="#自己的感受" class="headerlink" title="自己的感受"></a>自己的感受</h2><p>读完论文后，自己的想法</p>
<ul>
<li><p>time-to-target的benchmark的设计挺好的。没有数据集就自己造。</p>
</li>
<li><p>论文结构也很清晰明了，非常标准，感觉下次写论文的时候可以参考这篇论文写。</p>
</li>
<li><p>修改模糊测试的模块部分，也值得借鉴学习。</p>
</li>
<li><p>感谢作者开源了自己的工具，感觉能从代码中学习到不少东西。</p>
</li>
</ul>
<p>论文有哪些优点和亮点<br>论文还有哪些问题没有解决</p>
<p>测试的大型程序还不是很多，可以看看大型程序上的效果如何。</p>
<p>有哪些启发，可以继续探索</p>
<ul>
<li>exploitation和exploration的切换在代码中是怎么实现的</li>
<li>种子选择是怎么实现的</li>
<li>执行路径分析</li>
</ul>
]]></content>
      <tags>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title>源码解析angr模拟执行</title>
    <url>/2021/09/01/angr%20simulation_manage%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<h1 id="angr模拟执行源码解析"><a href="#angr模拟执行源码解析" class="headerlink" title="angr模拟执行源码解析"></a>angr模拟执行源码解析</h1><p>前言</p>
<p>angr是很有名的二进制符号执行工具，网上有许多关于angr的源码解析的文章。但是好像还没有关于angr模拟执行模块的解析。而模拟执行部分也是angr中相当重要的一个部分。因此，本文将解析angr模拟执行部分的源码，来帮助大家了解angr模拟执行的基本原理。</p>
<p>概述</p>
<p>当我们用angr去符号执行的时候，最基本的几个操作如下面代码所示：导入代码（第1行）、导入二进制（第2行）、确定初始状态（第3行）、构建simulation_manager对象（第4行）、符号执行（第5行）。而到底angr是怎么符号执行的呢？因此就需要深入simulation_manager的源码去一探究竟了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import angr</span><br><span class="line">p = angr.Project(&quot;xxxx&quot;)</span><br><span class="line">entry_state = p.factory.entry_state()</span><br><span class="line">simgr = p.factory.simgr(entry_state)</span><br><span class="line">simgr.explore(find=xxxx)</span><br></pre></td></tr></table></figure>

<p>simulation_manager这个类位于angr&#x2F;sim_manager.py文件里。</p>
<p>simulation_manager是angr中模拟执行管理器。主要的操作对象是程序的状态对象（sim_state）。状态都被放在stash里，可以往前执行、过滤、合并或者移到别的stash里。stash里可以理解为是放状态的一个列表，stash有这么几种，分别表示状态的状态：</p>
<ul>
<li>active：保存接下来要执行的状态</li>
<li>deadended：由于某些原因不能再继续执行下去，比如没有合法的指令、下个节点的状态不可解，或者有一个非法的指令指针。</li>
<li>pruned：当使用lazy_sovles的策略时，只有在必要的时候才去检查状态是否可解。当发现一个不可求解的节点后，将其后面的节点都优化掉，放在pruned里。</li>
<li>unconstrained：比如PC被用户数据或者其他类型的符号变量所控制，导致不知道执行哪个指令。</li>
<li>unsat：不可求解的状态。比如，输入同时为AAAA和BBBB。</li>
</ul>
<p>接下来看看源码，源码中提示我们看simulation_manager的三个重要方法：step、explore、use_technique。</p>
<h3 id="use-technique"><a href="#use-technique" class="headerlink" title="use_technique"></a>use_technique</h3><p>angr里有自带很多启发式的路径探索方法。这个函数就是让simulation_manager能够调用外部写好的启发式路径搜索方法。官方给出的几个样例里，除了经典的深度优先搜索、也有检测内存使用情况、CMU论文里的Veritest（合并循环的状态）等等策略。</p>
<p>代码首先先判断tech是否属于ExplorationTechnique这个类。然后setup方法开始初始化。然后把tech防到techniques列表中去，这也意味着可以使用多种策略。这里的hookset暂时没有看懂。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">use_technique</span>(<span class="params">self, tech</span>):</span><br><span class="line">       <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       Use an exploration technique with this SimulationManager.</span></span><br><span class="line"><span class="string">       Techniques can be found in :mod:`angr.exploration_techniques`.</span></span><br><span class="line"><span class="string">       :param tech:    An ExplorationTechnique object that contains code to modify</span></span><br><span class="line"><span class="string">                       this SimulationManager&#x27;s behavior.</span></span><br><span class="line"><span class="string">       :type tech:     ExplorationTechnique</span></span><br><span class="line"><span class="string">       :return:        The technique that was added, for convenience</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(tech, ExplorationTechnique):</span><br><span class="line">           <span class="keyword">raise</span> SimulationManagerError</span><br><span class="line"></span><br><span class="line">       <span class="comment"># <span class="doctag">XXX:</span> as promised</span></span><br><span class="line">       tech.project = self._project</span><br><span class="line">       tech.setup(self)</span><br><span class="line"></span><br><span class="line">       HookSet.install_hooks(self, **tech._get_hooks())</span><br><span class="line">       self._techniques.append(tech)</span><br><span class="line">       <span class="keyword">return</span> tech</span><br></pre></td></tr></table></figure>



<h3 id="explore"><a href="#explore" class="headerlink" title="explore"></a>explore</h3><p>先来看看看explore函数的参数，有stash，n，find，avoid等参数。explore函数的功能是从某个类型的stash，比如active，开始寻找满足find条件的，需要避免avoid条件的状态，直到找了n次，或者找到了num_find个状态。然后找到的状态都会塞到find_stash里，筛选的状态都会放在avoid_stash里。</p>
<p>其中find和avoid参数可以是一个地址，或者一堆地址的集合或者列表，甚至可以是一个函数，以状态为输入，输出True 或者False，来表示该状态是否是要寻找的状态。如果angr的CFG作为cfg的参数并且find是一个地址或者一个列表或者集合，那么到达不了目标状态的状态就会先把提前筛选掉。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">explore</span>(<span class="params">self, stash=<span class="string">&#x27;active&#x27;</span>, n=<span class="literal">None</span>, find=<span class="literal">None</span>, avoid=<span class="literal">None</span>, find_stash=<span class="string">&#x27;found&#x27;</span>, avoid_stash=<span class="string">&#x27;avoid&#x27;</span>, cfg=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">                num_find=<span class="number">1</span>, **kwargs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Tick stash &quot;stash&quot; forward (up to &quot;n&quot; times or until &quot;num_find&quot; states are found), looking for condition &quot;find&quot;,</span></span><br><span class="line"><span class="string">        avoiding condition &quot;avoid&quot;. Stores found states into &quot;find_stash&#x27; and avoided states into &quot;avoid_stash&quot;.</span></span><br><span class="line"><span class="string">        The &quot;find&quot; and &quot;avoid&quot; parameters may be any of:</span></span><br><span class="line"><span class="string">        - An address to find</span></span><br><span class="line"><span class="string">        - A set or list of addresses to find</span></span><br><span class="line"><span class="string">        - A function that takes a state and returns whether or not it matches.</span></span><br><span class="line"><span class="string">        If an angr CFG is passed in as the &quot;cfg&quot; parameter and &quot;find&quot; is either a number or a list or a set, then</span></span><br><span class="line"><span class="string">        any states which cannot possibly reach a success state without going through a failure state will be</span></span><br><span class="line"><span class="string">        preemptively avoided.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        num_find += <span class="built_in">len</span>(self._stashes[find_stash]) <span class="keyword">if</span> find_stash <span class="keyword">in</span> self._stashes <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        tech = self.use_technique(Explorer(find, avoid, find_stash, avoid_stash, cfg, num_find))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Modify first Veritesting so that they can work together.</span></span><br><span class="line">        deviation_filter_saved = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> self._techniques:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(t,Veritesting):</span><br><span class="line">                deviation_filter_saved = t.options.get(<span class="string">&quot;deviation_filter&quot;</span>,<span class="literal">None</span>)</span><br><span class="line">                <span class="keyword">if</span> deviation_filter_saved <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    t.options[<span class="string">&quot;deviation_filter&quot;</span>] = <span class="keyword">lambda</span> s: tech.find(s) <span class="keyword">or</span> tech.avoid(s) <span class="keyword">or</span> deviation_filter_saved(s)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    t.options[<span class="string">&quot;deviation_filter&quot;</span>] = <span class="keyword">lambda</span> s: tech.find(s) <span class="keyword">or</span> tech.avoid(s)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.run(stash=stash, n=n, **kwargs)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            self.remove_technique(tech)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> self._techniques:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(t,Veritesting):</span><br><span class="line">                <span class="keyword">if</span> deviation_filter_saved <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">del</span> t.options[<span class="string">&quot;deviation_filter&quot;</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    t.options[<span class="string">&quot;deviation_filter&quot;</span>] = deviation_filter_saved</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>宏观来看explore函数分为三部分：初始化，兼容veritest策略，探索（run）。兼容veritest策略的代码占了很多，对于理解veritest策略与其他策略的关系很有帮助，但是对我们理解符号执行帮助较小，这里就不赘述了。</p>
<p>首先，更新num_find的参数为设定的num_find参数加上找到的状态。接着，用传入的参数find，avoid等生成Explorer对象，然后再用use_technique方法生成一个tech对象。这里为什么要生成Explore对象，然后再用use_technique方法？</p>
<p>Explorer对象继承了ExplorationTechnique类，所以他也是一种探索策略，并且是一种最基础的策略。</p>
<p>而符号执行过程中，可以使用多种策略，那么如何综合这些策略呢？angr是把他们都放在了simulation_manager里的_.techniques列表里，而use_technique方法的作用正是把策略对象放进这个techniques列表里。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num_find += <span class="built_in">len</span>(self._stashes[find_stash]) <span class="keyword">if</span> find_stash <span class="keyword">in</span> self._stashes <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">tech = self.use_technique(Explorer(find, avoid, find_stash, avoid_stash, cfg, num_find))</span><br></pre></td></tr></table></figure>

<p>初始化后，接下来就是去探索状态部分。简单的一个try，finally语句。不论run的结果如何，最后都把基础探索策略移出_techniques列表里。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">	self.run(stash=stash, n=n, **kwargs)</span><br><span class="line">finally:</span><br><span class="line">	self.remove_technique(tech)</span><br></pre></td></tr></table></figure>

<p>run函数的代码如下，思路很简单，根据当前的探索策略，一直探索，直到到达一个完整的状态。如果策略里没定义完整的策略，那就把stash里的状态都跑完。run里涉及到了后面会讲的step函数，这里可以先简单理解为单步符号执行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, stash=<span class="string">&#x27;active&#x27;</span>, n=<span class="literal">None</span>, until=<span class="literal">None</span>, **kwargs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Run until the SimulationManager has reached a completed state, according to</span></span><br><span class="line"><span class="string">        the current exploration techniques. If no exploration techniques that define a completion</span></span><br><span class="line"><span class="string">        state are being used, run until there is nothing left to run.</span></span><br><span class="line"><span class="string">        :param stash:       Operate on this stash</span></span><br><span class="line"><span class="string">        :param n:           Step at most this many times</span></span><br><span class="line"><span class="string">        :param until:       If provided, should be a function that takes a SimulationManager and</span></span><br><span class="line"><span class="string">                            returns True or False. Stepping will terminate when it is True.</span></span><br><span class="line"><span class="string">        :return:            The simulation manager, for chaining.</span></span><br><span class="line"><span class="string">        :rtype:             SimulationManager</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> (itertools.count() <span class="keyword">if</span> n <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="built_in">range</span>(<span class="number">0</span>, n)):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.complete() <span class="keyword">and</span> self._stashes[stash]:</span><br><span class="line">                self.step(stash=stash, **kwargs)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> (until <span class="keyword">and</span> until(self)):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br></pre></td></tr></table></figure>

<h3 id="step"><a href="#step" class="headerlink" title="step"></a>step</h3><p>最后就是这个比较复杂的step函数了，可以看作是符号执行的基本单元了。相比explore函数的参数多了selector_func，step_func，successor_func，filter_func，until。这些参数的意思代码注释写得比较清楚了，就简单翻译一下。这些参数都是一个以状态为输入，返回各种东西（比如bool值，后继节点等）的一个函数，类似下面的代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">state</span>):</span><br><span class="line">	<span class="keyword">if</span> state.addr == xxxx:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<ol>
<li>selector_func：如果为True，将会继续步进，反之会被保留。</li>
<li>successor_func：返回的是后继节点，后面将会使用这些后继节点去符号执行。反之，则是使用project.factory.successors的后继节点。</li>
<li>filter_func：返回的是stash的名字。filter_func的主要作用是给状态分类，分到各个stash里去。</li>
<li>step_func：与前面参数不同，输入是为simulation_manger对象，并返回simulation_manager对象。这个函数会在simulation_manager对象每次step的时候被调用。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">step</span>(<span class="params">self, stash=<span class="string">&#x27;active&#x27;</span>, n=<span class="literal">None</span>, selector_func=<span class="literal">None</span>, step_func=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">            successor_func=<span class="literal">None</span>, until=<span class="literal">None</span>, filter_func=<span class="literal">None</span>, **run_args</span>):</span><br><span class="line">       <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       Step a stash of states forward and categorize the successors appropriately.</span></span><br><span class="line"><span class="string">       The parameters to this function allow you to control everything about the stepping and</span></span><br><span class="line"><span class="string">       categorization process.</span></span><br><span class="line"><span class="string">       :param stash:           The name of the stash to step (default: &#x27;active&#x27;)</span></span><br><span class="line"><span class="string">       :param selector_func:   If provided, should be a function that takes a state and returns a</span></span><br><span class="line"><span class="string">                               boolean. If True, the state will be stepped. Otherwise, it will be</span></span><br><span class="line"><span class="string">                               kept as-is.</span></span><br><span class="line"><span class="string">       :param step_func:       If provided, should be a function that takes a SimulationManager and</span></span><br><span class="line"><span class="string">                               returns a SimulationManager. Will be called with the SimulationManager</span></span><br><span class="line"><span class="string">                               at every step. Note that this function should not actually perform any</span></span><br><span class="line"><span class="string">                               stepping - it is meant to be a maintenance function called after each step.</span></span><br><span class="line"><span class="string">       :param successor_func:  If provided, should be a function that takes a state and return its successors.</span></span><br><span class="line"><span class="string">                               Otherwise, project.factory.successors will be used.</span></span><br><span class="line"><span class="string">       :param filter_func:     If provided, should be a function that takes a state and return the name</span></span><br><span class="line"><span class="string">                               of the stash, to which the state should be moved.</span></span><br><span class="line"><span class="string">       :param until:           (DEPRECATED) If provided, should be a function that takes a SimulationManager and</span></span><br><span class="line"><span class="string">                               returns True or False. Stepping will terminate when it is True.</span></span><br><span class="line"><span class="string">       :param n:               (DEPRECATED) The number of times to step (default: 1 if &quot;until&quot; is not provided)</span></span><br><span class="line"><span class="string">       Additionally, you can pass in any of the following keyword args for project.factory.successors:</span></span><br><span class="line"><span class="string">       :param jumpkind:        The jumpkind of the previous exit</span></span><br><span class="line"><span class="string">       :param addr:            An address to execute at instead of the state&#x27;s ip.</span></span><br><span class="line"><span class="string">       :param stmt_whitelist:  A list of stmt indexes to which to confine execution.</span></span><br><span class="line"><span class="string">       :param last_stmt:       A statement index at which to stop execution.</span></span><br><span class="line"><span class="string">       :param thumb:           Whether the block should be lifted in ARM&#x27;s THUMB mode.</span></span><br><span class="line"><span class="string">       :param backup_state:    A state to read bytes from instead of using project memory.</span></span><br><span class="line"><span class="string">       :param opt_level:       The VEX optimization level to use.</span></span><br><span class="line"><span class="string">       :param insn_bytes:      A string of bytes to use for the block instead of the project.</span></span><br><span class="line"><span class="string">       :param size:            The maximum size of the block, in bytes.</span></span><br><span class="line"><span class="string">       :param num_inst:        The maximum number of instructions.</span></span><br><span class="line"><span class="string">       :param traceflags:      traceflags to be passed to VEX. Default: 0</span></span><br><span class="line"><span class="string">       :returns:           The simulation manager, for chaining.</span></span><br><span class="line"><span class="string">       :rtype:             SimulationManager</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       l.info(<span class="string">&quot;Stepping %s of %s&quot;</span>, stash, self)</span><br><span class="line">       <span class="comment"># 8&lt;----------------- Compatibility layer -----------------</span></span><br><span class="line">       <span class="keyword">if</span> n <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">or</span> until <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">           <span class="keyword">if</span> once(<span class="string">&#x27;simgr_step_n_until&#x27;</span>):</span><br><span class="line">               <span class="built_in">print</span>(<span class="string">&quot;\x1b[31;1mDeprecation warning: the use of `n` and `until` arguments is deprecated. &quot;</span></span><br><span class="line">                     <span class="string">&quot;Consider using simgr.run() with the same arguments if you want to specify &quot;</span></span><br><span class="line">                     <span class="string">&quot;a number of steps or an additional condition on when to stop the execution.\x1b[0m&quot;</span>)</span><br><span class="line">           <span class="keyword">return</span> self.run(stash, n, until, selector_func=selector_func, step_func=step_func,</span><br><span class="line">                           successor_func=successor_func, filter_func=filter_func, **run_args)</span><br><span class="line">       <span class="comment"># ------------------ Compatibility layer ----------------&gt;8</span></span><br><span class="line">       bucket = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> state <span class="keyword">in</span> self._fetch_states(stash=stash):</span><br><span class="line"></span><br><span class="line">           goto = self.<span class="built_in">filter</span>(state, filter_func=filter_func)</span><br><span class="line">           <span class="keyword">if</span> <span class="built_in">isinstance</span>(goto, <span class="built_in">tuple</span>):</span><br><span class="line">               goto, state = goto</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> goto <span class="keyword">not</span> <span class="keyword">in</span> (<span class="literal">None</span>, stash):</span><br><span class="line">               bucket[goto].append(state)</span><br><span class="line">               <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> <span class="keyword">not</span> self.selector(state, selector_func=selector_func):</span><br><span class="line">               bucket[stash].append(state)</span><br><span class="line">               <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">           pre_errored = <span class="built_in">len</span>(self._errored)</span><br><span class="line"></span><br><span class="line">           successors = self.step_state(state, successor_func=successor_func, **run_args)</span><br><span class="line">           <span class="comment"># handle degenerate stepping cases here. desired behavior:</span></span><br><span class="line">           <span class="comment"># if a step produced only unsat states, always add them to the unsat stash since this usually indicates a bug</span></span><br><span class="line">           <span class="comment"># if a step produced sat states and save_unsat is False, drop the unsats</span></span><br><span class="line">           <span class="comment"># if a step produced no successors, period, add the original state to deadended</span></span><br><span class="line"></span><br><span class="line">           <span class="comment"># first check if anything happened besides unsat. that gates all this behavior</span></span><br><span class="line">           <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">any</span>(v <span class="keyword">for</span> k, v <span class="keyword">in</span> successors.items() <span class="keyword">if</span> k != <span class="string">&#x27;unsat&#x27;</span>) <span class="keyword">and</span> <span class="built_in">len</span>(self._errored) == pre_errored:</span><br><span class="line">               <span class="comment"># then check if there were some unsats</span></span><br><span class="line">               <span class="keyword">if</span> successors.get(<span class="string">&#x27;unsat&#x27;</span>, []):</span><br><span class="line">                   <span class="comment"># only unsats. current setup is acceptable.</span></span><br><span class="line">                   <span class="keyword">pass</span></span><br><span class="line">               <span class="keyword">else</span>:</span><br><span class="line">                   <span class="comment"># no unsats. we&#x27;ve deadended.</span></span><br><span class="line">                   bucket[<span class="string">&#x27;deadended&#x27;</span>].append(state)</span><br><span class="line">                   <span class="keyword">continue</span></span><br><span class="line">           <span class="keyword">else</span>:</span><br><span class="line">               <span class="comment"># there were sat states. it&#x27;s okay to drop the unsat ones if the user said so.</span></span><br><span class="line">               <span class="keyword">if</span> <span class="keyword">not</span> self._save_unsat:</span><br><span class="line">                   successors.pop(<span class="string">&#x27;unsat&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span> to_stash, successor_states <span class="keyword">in</span> successors.items():</span><br><span class="line">               bucket[to_stash <span class="keyword">or</span> stash].extend(successor_states)</span><br><span class="line"></span><br><span class="line">       self._clear_states(stash=stash)</span><br><span class="line">       <span class="keyword">for</span> to_stash, states <span class="keyword">in</span> bucket.items():</span><br><span class="line">           self._store_states(to_stash <span class="keyword">or</span> stash, states)</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> step_func <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">           <span class="keyword">return</span> step_func(self)</span><br><span class="line">       <span class="keyword">return</span> self</span><br></pre></td></tr></table></figure>

<p>首先，从stash里取出一个状态，调用filter函数看下该状态最后要去哪个stash里，如果不是当前的stash，则把该状态塞到应该放的stash的地方，然后取下一个状态。调用selector函数，选择要保留的状态。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bucket = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"><span class="comment"># 依次从stash里取出状态</span></span><br><span class="line"><span class="keyword">for</span> state <span class="keyword">in</span> self._fetch_states(stash=stash): </span><br><span class="line">    goto = self.<span class="built_in">filter</span>(state, filter_func=filter_func) <span class="comment"># 返回的是个元组，（状态该去的stash，状态）</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(goto, <span class="built_in">tuple</span>):</span><br><span class="line">    	goto, state = goto</span><br><span class="line">    <span class="comment">#如果要去的stash不是当前的stash，也不是None，</span></span><br><span class="line">    <span class="keyword">if</span> goto <span class="keyword">not</span> <span class="keyword">in</span> (<span class="literal">None</span>, stash):</span><br><span class="line">        <span class="comment"># 那么把他放进该去的stash里，就不管他了。也就筛选掉了。</span></span><br><span class="line">    	bucket[goto].append(state) <span class="comment"># </span></span><br><span class="line">    	<span class="keyword">continue</span></span><br><span class="line">    <span class="comment"># 如果selector函数返回False，则需要保留该状态到当前的stash</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> self.selector(state, selector_func=selector_func):</span><br><span class="line">        <span class="comment"># 保留状态</span></span><br><span class="line">        bucket[stash].append(state)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>如果没有触发selector或者filter，就去找后继节点。这里调用了step_state函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> state <span class="keyword">in</span> self._fetch_states(stash=stash):</span><br><span class="line">    ...</span><br><span class="line">	successors = self.step_state(state, successor_func=successor_func, **run_args)</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p>step_state函数如下所示，这个函数主要是处理后继节点的状态。将不可解的状态，无约束的状态都放在相应的stash里。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">step_state</span>(<span class="params">self, state, successor_func=<span class="literal">None</span>, **run_args</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Don&#x27;t use this function manually - it is meant to interface with exploration techniques.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        successors = self.successors(state, successor_func=successor_func, **run_args)</span><br><span class="line">        stashes = &#123;<span class="literal">None</span>: successors.flat_successors,</span><br><span class="line">                   <span class="string">&#x27;unsat&#x27;</span>: successors.unsat_successors,</span><br><span class="line">                   <span class="string">&#x27;unconstrained&#x27;</span>: successors.unconstrained_successors&#125;	</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">return</span> stashes</span><br></pre></td></tr></table></figure>

<p>由于step_state函数可能会发生很多错误，因此后续的代码是去做后继节点错误状态的处理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> state <span class="keyword">in</span> self._fetch_states(stash=stash): </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">#如果有后继节点有任何一个unsat状态或者发生了新的错误</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">any</span>(v <span class="keyword">for</span> k, v <span class="keyword">in</span> successors.items() <span class="keyword">if</span> k != <span class="string">&#x27;unsat&#x27;</span>) <span class="keyword">and</span> <span class="built_in">len</span>(self._errored) == pre_errored:</span><br><span class="line">        <span class="comment">#对于unsat状态，就先不管他</span></span><br><span class="line">        <span class="keyword">if</span> successors.get(<span class="string">&#x27;unsat&#x27;</span>, []):</span><br><span class="line">            <span class="comment"># only unsats. current setup is acceptable.</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment">#如果不是unsat，那说明遇到某些原因终止了，把该状态加到deadended的stash里去。</span></span><br><span class="line">            bucket[<span class="string">&#x27;deadended&#x27;</span>].append(state)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 如果没有设置保留unsat状态，就把后继节点的unsat状态丢出去。</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._save_unsat:</span><br><span class="line">            successors.pop(<span class="string">&#x27;unsat&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line">	</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来就把后继节点加到bucket的to_stash或者stash里去。自此，这个for循环就结束了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> state <span class="keyword">in</span> self._fetch_states(stash=stash): </span><br><span class="line">...</span><br><span class="line">    <span class="keyword">for</span> to_stash, successor_states <span class="keyword">in</span> successors.items():</span><br><span class="line">        bucket[to_stash <span class="keyword">or</span> stash].extend(successor_states)</span><br></pre></td></tr></table></figure>

<p>剩下就是一些收尾工作，清空当前stash里的状态，然后再把bucket的内容存到simulation_manager对象的stash里去。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self._clear_states(stash=stash)</span><br><span class="line"><span class="keyword">for</span> to_stash, states <span class="keyword">in</span> bucket.items():</span><br><span class="line">	self._store_states(to_stash <span class="keyword">or</span> stash, states)</span><br></pre></td></tr></table></figure>

<p>如果有设置step_func，就去调用step_func。由此也能看到step_func是在step函数最后调用的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> step_func <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">	<span class="keyword">return</span> step_func(self)</span><br></pre></td></tr></table></figure>

<p>最后用张图来总结。</p>
<p>参考资料：</p>
<ul>
<li><a href="https://github.com/angr/angr/tree/master/angr">https://github.com/angr/angr/tree/master/angr</a></li>
</ul>
]]></content>
      <tags>
        <tag>symbolic execution</tag>
      </tags>
  </entry>
  <entry>
    <title>【论文笔记】Learning to Explore Paths for Symbolic Executio</title>
    <url>/2021/12/15/learch/</url>
    <content><![CDATA[<h1 id="Learning-to-Explore-Paths-for-Symbolic-Execution"><a href="#Learning-to-Explore-Paths-for-Symbolic-Execution" class="headerlink" title="Learning to Explore Paths for Symbolic Execution"></a>Learning to Explore Paths for Symbolic Execution</h1><blockquote>
<p>CCS 2021年的一篇关于符号执行路径选择优化的论文。</p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>符号执行是很强力的技术，能够生成测试样例来让程序执行想要的路径。然而，符号执行的扩展性受限于路径爆炸问题。因此，要提高符号执行的有效性，就要让符号执行能够选择正确的符号状态。</p>
<p>文章提出了一种基于学习的技术，能够有效地选择合适的状态来缓解路径爆炸问题。learch能够直接估计每个状态对最大化覆盖率这一目标的贡献。而不是像传统的启发式方法基于简单的策略。而且，learch利用了现有的启发式方法来生成训练数据和提取特征。因此，learch从其他专家设计的启发式方法中受益颇多。</p>
<p>在klee中实现了learch，同时评估了许多真实程序，结果表明，learch是有效的：能够覆盖更多的代码，比现有的启发式方法或者启发式的组合能检测出更多的bug。同时，我们也发现利用learch生成的测试样例作为fuzz的初始种子能够找到更多的路径和bug。</p>
<p>看了摘要以后有几个比较感兴趣的问题：</p>
<ol>
<li>什么叫做迭代式学习？</li>
<li>他是怎么生成数据集和提取特征的？</li>
<li>最后这个作为fuzz的初始种子的实验是怎么做的？</li>
</ol>
<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>文章阐述motivation的思路是：符号执行根本的问题（路径爆炸），现有的启发式方法无法解决。</p>
<p>路径爆炸体现在这张图，候选的符号执行状态非常的多。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20211213205132800.png" alt="image-20211213205132800"></p>
<p>现有启发式的局限体现在：没有任何的启发式方法要优于其他的启发式方法，每种启发式方法都覆盖了程序的各个部分，可以说是各有优缺点。组合起来的启发式方法效果不错。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20211213205224447.png" alt="image-20211213205224447"></p>
<p>基于组合启发式方法效果不错这一点，作者认为需要用一种学习的策略来有效地组合这几种启发式方法。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>文章的核心是使用机器学习的回归模型评估状态的对于最大化覆盖率这个目标的贡献值。基于这个模型，符号执行选择贡献值最大的状态。</p>
<p>文章采用的是迭代式学习策略，在每轮迭代中，用符号执行对训练程序跑一下。一开始使用不同的状态选择策略来生成一些测试样例。然后对每个已经探索过的状态，我们提取他的特征（包括启发式方法用到的那些特征），然后计算他们的reward，也就是前面提到的贡献值。</p>
<p>这就生成了监督的数据集并且俘获到了每个策略的行为。最后，再训练回归模型来让模型能够准确地对每个状态进行估计。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20211213192713177.png" alt="image-20211213192713177"></p>
<h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><p>符号执行的目标：在最短的时间达到最大的覆盖率</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20211213211024776.png" alt="image-20211213211024776"></p>
<p>reward的计算：从state状态生成的测试样例的覆盖率除以在状态d的时间</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20211213211048353.png" alt="image-20211213211048353"></p>
<p>标签是reward，计算方式是覆盖的行除以每个状态的时间。</p>
<p>设计的特征：</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20211215183459096.png" alt="image-20211215183459096"></p>
<p>标记了五种安全违反：</p>
<ul>
<li>整数溢出</li>
<li>Oversized shift</li>
<li>out-of-bounds array reads&#x2F;writes</li>
<li>pointer overflow</li>
<li>null deference</li>
</ul>
<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>主要回答这么几个问题：</p>
<ul>
<li><p>Can Learch cover more code than existing manual heuristics?</p>
</li>
<li><p>Can Learch discover more security violations?</p>
</li>
<li><p>Can Learch generate better initial seeds for fuzzing?</p>
</li>
<li><p>What is the impact of Learch’s design choices?</p>
</li>
</ul>
<p>数据集选择：</p>
<ul>
<li>coreutils是许多符号执行工作评测的程序集</li>
<li>程序的输入格式各种各样，并且广泛应用在fuzz和符号执行这些工作里</li>
</ul>
<p>对比的启发式方法：</p>
<ul>
<li>rss：random state search</li>
<li>rps：random path search</li>
<li>nurs cplint and nurs depth：non-uniform random search</li>
<li>sgs：subpath-guide search</li>
<li>portfolio</li>
</ul>
<h3 id="覆盖率"><a href="#覆盖率" class="headerlink" title="覆盖率"></a>覆盖率</h3><p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20211215185043665.png" alt="image-20211215185043665"></p>
<h3 id="发现的安全违反"><a href="#发现的安全违反" class="headerlink" title="发现的安全违反"></a>发现的安全违反</h3><p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20211215185301761.png" alt="image-20211215185301761"></p>
<h3 id="结合模糊测试的效果"><a href="#结合模糊测试的效果" class="headerlink" title="结合模糊测试的效果"></a>结合模糊测试的效果</h3><p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20211215185335767.png" alt="image-20211215185335767"></p>
<h3 id="影响（挖到的真实漏洞）"><a href="#影响（挖到的真实漏洞）" class="headerlink" title="影响（挖到的真实漏洞）"></a>影响（挖到的真实漏洞）</h3><p>发现了46个潜在漏洞，并且13个被认定为是真的bug。</p>
<h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>主要提到了符号执行、混合测试和机器学习应用到程序分析的一些工作。因为这方面都有些了解了，这里就不再详细介绍了，感兴趣的可以去看论文。</p>
]]></content>
      <tags>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title>漏洞自动化利用研究进展</title>
    <url>/2021/05/17/%E6%BC%8F%E6%B4%9E%E8%87%AA%E5%8A%A8%E5%88%A9%E7%94%A8AEG%E7%A0%94%E7%A9%B6%E8%BF%9B%E5%B1%95/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自从DARPA在2016搞了一个CGC比赛之后，关于漏洞自动利用工作的研究也在随后几年多了起来。国内近几年也有类似的比赛出现，比如RHG、BCTF的autopwn。此外，随着软件趋于复杂，模糊测试技术的成熟，漏洞数量也越来越多。要修补所有的漏洞不太现实，而人工去判断漏洞的危害性也是耗时耗力的过程。因此，这也就带动了漏洞自动利用生成（Automatic Exploit Generation）的发展。本文将基于近几年安全顶会上的研究，首先介绍漏洞自动化利用的研究进展，并给出一个漏洞自动利用的基本框架，最后讨论漏洞自动利用的未来研究方向。</p>
<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>近几年来，漏洞的CVE数量越来越多。一方面是因为模糊测试在漏洞挖掘领域取得了比较好的效果，另一方面是软件的越来越复杂，不可避免导致了很多安全漏洞。面对如此多数量的漏洞，对于一个安全团队是很难能够及时修复的。相关研究表明，漏洞修复的周期长达几周或几个月。因此，需要对漏洞修复的优先级进行排序。常用的策略是基于漏洞的可利用性来确定漏洞的优先级。然而，手工确定漏洞的可利用性也是耗时耗力的事情。这也就是漏洞自动化利用工具的意义所在，自动化地评估漏洞的可利用性，进而确定漏洞修复的优先级。</p>
<p>除了确定漏洞修复优先级以外，漏洞自动化利用也能对现有的防御机制进行评估，产生新的防御思路。此外，这类工具也能对CTF比赛或者渗透测试过程提供很大帮助。企业也能使用这类工具来对其系统安全风险预警。</p>
<p>总的来说，研究意义主要分为以下三点。</p>
<p>a. 确定漏洞可利用性<br>b. 自动化地去评估防御机制，促进防御的研究发展。<br>c. 辅助渗透测试，比如CTF等等。</p>
<h2 id="2-研究时间线"><a href="#2-研究时间线" class="headerlink" title="2. 研究时间线"></a>2. 研究时间线</h2><p>最早关于漏洞利用自动生成的研究是2008年的APEG[1]。这篇工作是基于一个打过补丁的程序，来自动生成没打过补丁的程序漏洞利用。应用到实际会有很多受限之处，但是开创了漏洞利用自动生成这个领域。随后，2009年，Heelan[2]的硕士论文是第一个提出给定一个程序的崩溃输入，然后自动生成这个漏洞的利用。后续的工作基本上也是按这个套路不断延申开来。2011年后，先前研究APEG的David团队先后发表了AEG[3]，Mayhem[4]等工作。早期的漏洞自动化利用工作基本都是由这个团队做的。到2016年，DARPA开了一个CGC的比赛（自动攻防），Mayhem取得了第一名。之后几年内，相关工作如春笋一般涌出。2016年算是个奇妙的时间点，2016之前的工作大都是围绕栈溢出，格式化字符串漏洞来做。2016年之后大多工作都开始尝试去实现堆漏洞（堆溢出、UAF）的自动化利用。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20210504134758216.png" alt="image-20210504134758216"></p>
<p>总结一下，漏洞自动化利用的发展的研究趋势，目前应该还有一些重要的工作需要去做。近几年的工作大都是将符号执行和模糊测试相结合来实现的，仿佛成为了一种范式。自然辩证法里有提到过科学是在范式下解难题。现在看来确实蛮符合科学发展的规律。</p>
<h2 id="3-基本方法"><a href="#3-基本方法" class="headerlink" title="3. 基本方法"></a>3. 基本方法</h2><p>这里简单介绍几篇论文里是如何实现AEG。并且大家可能会发现，思路都差不多，但研究的侧重点都不尽相同。</p>
<h3 id="3-1-针对栈溢出的AEG"><a href="#3-1-针对栈溢出的AEG" class="headerlink" title="3.1 针对栈溢出的AEG"></a>3.1 针对栈溢出的AEG</h3><p>早期的工作主要是针对栈溢出漏洞进行自动化利用，这些研究有Heelan的硕士论文[2], AEG[3]，Mayhem[4]，CRAX[5]等等</p>
<p>Heelan的工作需要给定一个已知漏洞的崩溃输入和跳转的寄存器，基于动态符号执行来自动化地劫持程序控制流。<br>具体来说，他使用二进制插桩来做污点传播并收集运行时信息，并通过检查EIP寄存器是否被污点影响来生成exp，同时也考虑了间接影响EIP寄存器的指针损坏的情况。</p>
<p>AEG这篇论文写得很清晰。文章的总体框架如下图所示。首先用gcc和llvm对源码进行预处理，生成能用GCC运行的二进制Bgcc和LLVM分析的字节码Bllvm。基于字节码，AEG用条件符号执行去找漏洞函数，被溢出覆盖的对象，触发bug的路径。同时用动态二进制分析去Bgcc里提取运行时信息，最后生成payload。生成payload后再进行验证，最后输出exploit。（下图来自于论文。）</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20200907154844716.png" alt="image-20200907154844716"></p>
<p>mayhem这篇文章就是上面AEG在二进制上的逻辑扩展。核心技术是混合符号执行和基于索引的内存模型。用混合符号执行主要是在运行速度和内存要求之间找平衡点。mayhem引入了具体执行来缓解符号执行带来的路径爆炸问题。具体来说，具体执行插桩，做动态污点分析，然后把污点指令流传给SES。SES编译这些指令为中间语言，并且符号化地去执行。简单来说就是具体执行缩小了符号执行需要执行的范围。而基于索引的内存模型主要是去解决产生exploit由于具体的约束条件而不可行，因此引入整个模型来避免索引的约束。（下图来自于论文。）</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20200907160712400.png" alt="image-20200907160712400"></p>
<p>CRAX主要是针对AEG中的一个缺陷做的改进。AEG收集运行时信息，并且只在漏洞触发的时候计算exp。产生的exp可能会由于漏洞点和触发exp点的传播距离而失效。比如下面的代码。漏洞点在第四行的strcpy，触发漏洞是在第六行函数返回的时候，而这个时候第五行修改了之前计算的exp，就会导致最后的exp失效。（下图来自于论文。）</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20210304093522324.png" alt="image-20210304093522324"></p>
<p>CRAX的方法和angr文档里的simple AEG的思路很像。第一步是去找符号化的EIP，也就是看输入能否控制程序指针PC。第二步是找到符号化的内存，看看能否注入shellcode。当确定了shellcode的位置后，CRAX会在shellcode前面放很多的滑板指令NOP来扩充shellcode的入口。最后，所有的约束，包括shellcode，NOP sled，EIP寄存器的约束都会送到solver去求解，得到最终的exp。如果得不到解，就会去改变shellcode的位置，直到求出解或者没有可用的符号buffer了。（下图来自于论文。）</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20210304092057582.png" alt="image-20210304092057582"></p>
<h3 id="3-2-针对堆溢出的AEG"><a href="#3-2-针对堆溢出的AEG" class="headerlink" title="3.2 针对堆溢出的AEG"></a>3.2 针对堆溢出的AEG</h3><p>针对堆漏洞的自动化利用工作到2016年以后才陆续开始出现。这也是近几年来的研究热点。我认为有几个原因：</p>
<p>a. 相比栈漏洞，堆漏洞的利用更为复杂，更需要自动化利用工具来对其进行评估<br>b. 先前的工作主要是针对栈上的漏洞，做堆漏洞的工作在2016年前没有<br>c. 堆漏洞在这几年增加的要比栈漏洞快</p>
<p>由于堆利用复杂性，有些工作聚焦于堆布局的自动化。比如Usenix18 的SHRIKE[6]和CCS 19 的slake[7]，分别是针对解释器和内核的堆漏洞的自动化操纵布局。</p>
<p>SHRIKE是第一个堆布局自动化操纵的研究，其方法是基于伪随机黑盒搜索。SLAKE使用动态和静态分析来分析内核对象和相应的系统调用。然后，对常用的利用方法进行建模，最后实现了一种slab布局调整的方法。</p>
<p>下面介绍的针对各类应用场景堆漏洞的AEG工作，比如浏览器、内核、解释器等。</p>
<p><strong>REVERY</strong>[8]</p>
<p>现有的AEG方法通常是探索crashing path来找到可利用的状态，比如由PoC触发的漏洞的路径和生成的利用通常是在一条路径上。然而，1.可利用的状态不一定总在crashing path上。2.并且，现有的方法严重依赖符号执行，并且在路径扩展和利用生成的扩展性不好。</p>
<p>为了解决这两个问题，revery使用了三种技术：</p>
<p>0x1. layout-contributor digraph 来描述漏洞的内存布局和指令<br>0x2. layout-oriented fuzzing去探索和crashing paths有相同内存布局的路径<br>0x3. control-flow stitching 来连接crashing paths和diverging path，最后生成利用。</p>
<p>（下图来自于论文。）</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20210307154143717.png" alt="image-20210307154143717"></p>
<p><strong>HEAPG</strong>[9]</p>
<p>由于现有的方法都是通过破坏一个敏感指针然后实现一个内存读写或者间接调用，也就是说敏感指针是劫持控制流的关键。在这个例子里，一旦堆布局准备好，攻击者只要一次就可以构造利用原语。然后实际很多漏洞需要多个步骤才能实现利用。为了实现这点，HEAPG利用专家知识来指导利用生成。具体来说，HEAPG，以crashing input,二进制程序和专家知识作为输入，然后通过利用堆分配器内部的特性，能够对很难利用的漏洞生成利用。（下图来自于论文。）</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20210307153406563.png" alt="image-20210307153406563"></p>
<p><strong>PrimGen</strong>[10]</p>
<p>针对浏览器这类有广大用户人群，且极为复杂的软件，其漏洞利用过程通常是个耗时耗力，多步骤的过程。为了减轻安全人员的工作量，PrimGen自动化了部分浏览器漏洞的利用过程。对于给定的一个漏洞，PrimGen能够自动构造数据对象喂给浏览器导致执行恶意行为。</p>
<p>PrimGen主要分为两部分，第一部分预处理，基于二进制程序生成CFG和SSA，并且收集一些数据，比如函数的entry，寄存器的定义&#x2F;使用，内存读写和控制流信息。更进一步，PrimGen利用动态分析来获取控制流和内存信息（利用debugger在控制点下断点来执行crashing input。）然后就可以提取动态踪迹和内存信息。</p>
<p>第二部分用datalog-based方法去找控制点后的可控数据。在确定了控制点的位置后，开启分析去找到可到达的sink。基于这些信息，构造了一个图来描述从一个基本块到另外一个基本块的控制流。有了这些图，再利用符号执行去执行到sink的路径，并过滤掉不可解的路径。在这个步骤中，会收集所有与控制数据相关的约束，并且用于构建内存映射表。基于映射表可以指导如何构造对象。基于前面动态分析获得的memory dump，PrimGen可以验证每条与内存映射绑定的路径是否满足利用条件。最后，给定一个VUT的堆喷射模板，PrimGen的模型可以生成喂给浏览器的脚本。（下图来自于论文。）</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20210504141153860.png" alt="image-20210504141153860"></p>
<p><strong>Gollum</strong>[11]</p>
<p>gollum是第一个针对解释器堆溢出漏洞的AEG研究。文章提到大多数的AEG系统针对的是命令行的程序或者类似文件解析器的系统。而解释器和这些程序不一样，并且打破了现有AEG系统的假设。一个假设是利用符号执行可以推断输入文件和目标行为的关系。而解释器的状态空间很大，并且输入程序的值和程序状态有很多非直接的关系。解释器有很多漏洞，但这里针对堆溢出漏洞有2个原因，一是堆漏洞比较常见，二是现有AEG系统做的还不够完善。</p>
<p>文章关于堆布局的自动操作是基于作者之前工作SHRIKE的基础上。另外文章的亮点还在于用了遗传算法来代替之前的伪随机搜索算法。感兴趣的可以去看论文。（下图来自于论文。）</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20210307153826751.png" alt="image-20210307153826751"></p>
<p><strong>FUZE</strong>[12]</p>
<p>FUZE针对的是内核的UAF漏洞。这是篇将符号执行与模糊测试结合的AEG文章。具体来说，从漏洞触发点开始用模糊测试探索路径。然后在指针解引用的地方用符号执行再去探索路径。（下图来自于论文。）</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20210307172811930.png" alt="image-20210307172811930"></p>
<p><strong>KOOBE</strong>[13]</p>
<p>KOOBE针对是内核的Out-of-Bound(OOB)漏洞。针对现有的方法无法完全挖掘漏洞的能力，KOOBE定义了OOB漏洞的能力为三点：能写多远、能写多少、能写什么。并利用OOB漏洞的能力来指导模糊测试。（下图来自于论文。）</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20210307153714379.png" alt="image-20210307153714379"></p>
<h3 id="3-3-针对其他漏洞的AEG"><a href="#3-3-针对其他漏洞的AEG" class="headerlink" title="3.3 针对其他漏洞的AEG"></a>3.3 针对其他漏洞的AEG</h3><p>这篇文章[14]提出了一个完整的自动化目标栈喷射方法来自动化利用内核的未初始化漏洞。目标栈喷射技术包含两点：</p>
<p>a. 确定的栈喷射技术，结合定制的符号执行和模糊测试来识别内核输入，这个内核输入指的是攻击者利用用户程序在确定地执行内核代码路径，从而在内核栈上留下攻击者控制的数据。<br>b. 内存喷射技术，使用内存占用和污染来可靠地控制内核栈上的一大块空间。</p>
<p>所以，这两个技术概括来说，一个是精准定位，一个是大面积覆盖。并且作者利用这个技术和未初始化漏洞可以实现提权。此外，作者还提供了一种基于编译器的防御机制，来初始化可能不安全的指针类型，并且没有太多的额外性能。文章的结果显示，未初始化使用是一个很严重的攻击，所以未来的防御系统需要考虑这种漏洞，并且系统软件不应该使用未初始化内存来作为随机源。（下图来自于论文。）</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20210307172942260.png" alt="image-20210307172942260"></p>
<h2 id="4-评估方法"><a href="#4-评估方法" class="headerlink" title="4. 评估方法"></a>4. 评估方法</h2><p>目前的评估数据集主要有三类：</p>
<pre><code>a. CVE漏洞

b. syzbot平台上的漏洞（谷歌用fuzzer找到的内核漏洞）

c. CTF比赛程序
</code></pre>
<p>CVE漏洞的优点在于其是真实存在的漏洞。用CVE来做测试集，工具的实际意义比较大。</p>
<p>大部分的工作用的都是实际的CVE来做评估测试。一些内核漏洞的工作会用到syzbot平台。因为syzbot平台上的漏洞还没经过评估成为CVE，有比较大的评估价值。</p>
<p>Revery[8]和KEPLER[15]用到了一些CTF比赛的数据集。这类数据集的优点前期测试工具比较方便，网上也有相应的exploit。但存在问题是这类程序的规模一般不大，可能无法评估工具能否实用。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20200907143212604.png" alt="image-20200907143212604"></p>
<h2 id="5-未来可能研究方向"><a href="#5-未来可能研究方向" class="headerlink" title="5. 未来可能研究方向"></a>5. 未来可能研究方向</h2><p>如何对漏洞进行建模是这个领域的一个难点。建模时需要考虑漏洞的类型，漏洞程序的类型（浏览器，内核），漏洞的能力（能写多远，能写多少字节，能写什么值）。因为现有的漏洞自动化利用的实现主要是基于符号执行和模糊测试，而这两种技术都存在搜索空间很大的弊病。因此，充分利用漏洞的信息能够在一定程度上降低搜索空间。比如KOOBE这篇文章就是将漏洞能力融入到模糊测试中去，进而提高了模糊测试的效率。</p>
<p>未来的研究可能会针对更多更难利用的漏洞去实现AEG，比如竞争？或者针对更广的应用场景，比如嵌入式设备、固件？此外漏洞自动利用还有个难以解决的问题，就是<strong>如何确定漏洞的可利用性的边界</strong>。现有的工作对这个问题的回答还不是很好。因为目前的工具不能生成一个漏洞的利用，并不代表这个漏洞是否不可利用，有可能是工具自身的问题。当然这也是个很困难的问题。</p>
<h2 id="6-开源工具"><a href="#6-开源工具" class="headerlink" title="6. 开源工具"></a>6. 开源工具</h2><p><strong>劫持控制流</strong></p>
<p>PrimGen：浏览器堆漏洞自动化利用(目前只有结果，作者说code will follow)</p>
<blockquote>
<p><a href="https://github.com/RUB-SysSec/PrimGen">https://github.com/RUB-SysSec/PrimGen</a></p>
</blockquote>
<p>FUZE：内核UAF漏洞自动化利用</p>
<blockquote>
<p><a href="https://github.com/ww9210/Linux_kernel_exploits">https://github.com/ww9210/Linux_kernel_exploits</a></p>
</blockquote>
<p>Gollum：解释器堆溢出漏洞自动化利用（有链接但暂未开源）</p>
<blockquote>
<p><a href="https://github.com/SeanHeelan/ShapeShifter">https://github.com/SeanHeelan/ShapeShifter</a></p>
</blockquote>
<p>KOOBE：内核越界写（OOB）漏洞自动化利用</p>
<blockquote>
<p><a href="https://github.com/seclab-ucr/KOOBE">https://github.com/seclab-ucr/KOOBE</a></p>
</blockquote>
<p>rex：angr参加CGC比赛的工具</p>
<blockquote>
<p><a href="https://github.com/angr/rex">https://github.com/angr/rex</a></p>
</blockquote>
<p>Zeratool：栈溢出自动化利用工具</p>
<blockquote>
<p> <a href="https://github.com/ChrisTheCoolHut/Zeratool">https://github.com/ChrisTheCoolHut/Zeratool</a></p>
</blockquote>
<p><strong>堆布局操作</strong></p>
<p>SHRIKE：堆溢出漏洞布局操作自动化</p>
<blockquote>
<p><a href="https://github.com/SeanHeelan/HeapLayout">https://github.com/SeanHeelan/HeapLayout</a></p>
</blockquote>
<p>SLAKE：四种漏洞的堆布局操作自动化(暂时不完善)</p>
<blockquote>
<p><a href="https://github.com/chenyueqi/SLAKE">https://github.com/chenyueqi/SLAKE</a></p>
</blockquote>
<p><strong>绕过防御机制</strong></p>
<p>BOPC：绕过防御机制（数据流攻击自动化）</p>
<blockquote>
<p><a href="https://github.com/HexHive/BOPC">https://github.com/HexHive/BOPC</a></p>
</blockquote>
<p>KEPLER：绕过防御机制（内核ROP）</p>
<blockquote>
<p><a href="https://github.com/ww9210/kepler-cfhp">https://github.com/ww9210/kepler-cfhp</a></p>
</blockquote>
<p><strong>一些相关资料，及几篇最近的综述</strong></p>
<p>github上关于AEG论文的整理：<a href="https://github.com/SCUBSRGroup/Automatic-Exploit-Generation">https://github.com/SCUBSRGroup/Automatic-Exploit-Generation</a></p>
<p>赵尚儒,李学俊,方越,余媛萍,黄伟豪,陈恺,苏璞睿,张玉清.安全漏洞自动利用综述[J].计算机研究与发展,2019,56(10):2097-2111.</p>
<p>苏璞睿,黄桦烽,余媛萍,张涛.软件漏洞自动利用研究综述[J].广州大学学报(自然科学版),2019,18(03):52-58.</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] Brumley D, Poosankam P, Song D, et al. Automatic patch-based exploit generation is possible: Techniques and implications[C]&#x2F;&#x2F;2008 IEEE Symposium on Security and Privacy (sp 2008). IEEE, 2008: 143-157.</p>
<p>[2] Heelan S. Automatic generation of control flow hijacking exploits for software vulnerabilities[D]. University of Oxford, 2009.</p>
<p>[3] Avgerinos T, Cha S K, Rebert A, et al. Automatic exploit generation[C]&#x2F;&#x2F;NDSS. 2011.</p>
<p>[4] Cha S K, Avgerinos T, Rebert A, et al. Unleashing mayhem on binary code[C]&#x2F;&#x2F;2012 IEEE Symposium on Security and Privacy. IEEE, 2012: 380-394.</p>
<p>[5] Huang S K, Huang M H, Huang P Y, et al. Crax: Software crash analysis for automatic exploit generation by modeling attacks as symbolic continuations[C]&#x2F;&#x2F;2012 IEEE Sixth International Conference on Software Security and Reliability. IEEE, 2012: 78-87.</p>
<p>[6] Heelan S, Melham T, Kroening D. Automatic heap layout manipulation for exploitation[C]&#x2F;&#x2F;27th {USENIX} Security Symposium ({USENIX} Security 18). 2018: 763-779.</p>
<p>[7] Chen Y, Xing X. Slake: facilitating slab manipulation for exploiting vulnerabilities in the Linux kernel[C]&#x2F;&#x2F;Proceedings of the 2019 ACM SIGSAC Conference on Computer and Communications Security. 2019: 1707-1722.</p>
<p>[8] Wang Y, Zhang C, Xiang X, et al. Revery: From proof-of-concept to exploitable[C]&#x2F;&#x2F;Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security. 2018: 1914-1927.</p>
<p>[9] Zhao Z, Wang Y, Gong X. HAEPG: An Automatic Multi-hop Exploitation Generation Framework[C]&#x2F;&#x2F;International Conference on Detection of Intrusions and Malware, and Vulnerability Assessment. Springer, Cham, 2020: 89-109.</p>
<p>[10] Garmany B, Stoffel M, Gawlik R, et al. Towards automated generation of exploitation primitives for web browsers[C]&#x2F;&#x2F;Proceedings of the 34th Annual Computer Security Applications Conference. 2018: 300-312.</p>
<p>[11] Heelan S, Melham T, Kroening D. Gollum: Modular and greybox exploit generation for heap overflows in interpreters[C]&#x2F;&#x2F;Proceedings of the 2019 ACM SIGSAC Conference on Computer and Communications Security. 2019: 1689-1706.</p>
<p>[12] Wu W, Chen Y, Xu J, et al. {FUZE}: Towards facilitating exploit generation for kernel use-after-free vulnerabilities[C]&#x2F;&#x2F;27th {USENIX} Security Symposium ({USENIX} Security 18). 2018: 781-797.</p>
<p>[13] Chen W, Zou X, Li G, et al. {KOOBE}: Towards Facilitating Exploit Generation of Kernel Out-Of-Bounds Write Vulnerabilities[C]&#x2F;&#x2F;29th {USENIX} Security Symposium ({USENIX} Security 20). 2020: 1093-1110.</p>
<p>[14] Lu K, Walter M T, Pfaff D, et al. Unleashing Use-Before-Initialization Vulnerabilities in the Linux Kernel Using Targeted Stack Spraying[C]&#x2F;&#x2F;NDSS. 2017.</p>
<p>[15] Wu W, Chen Y, Xing X, et al. {KEPLER}: Facilitating Control-flow Hijacking Primitive Evaluation for Linux Kernel Vulnerabilities[C]&#x2F;&#x2F;28th {USENIX} Security Symposium ({USENIX} Security 19). 2019: 1187-1204.</p>
]]></content>
      <tags>
        <tag>survey</tag>
      </tags>
  </entry>
  <entry>
    <title>内存时间安全防御研究进展</title>
    <url>/2021/04/29/%E5%86%85%E5%AD%98%E6%97%B6%E9%97%B4%E5%AE%89%E5%85%A8%E9%98%B2%E5%BE%A1%E7%A0%94%E7%A9%B6%E8%BF%9B%E5%B1%95/</url>
    <content><![CDATA[<h1 id="内存时间安全防御研究进展"><a href="#内存时间安全防御研究进展" class="headerlink" title="内存时间安全防御研究进展"></a>内存时间安全防御研究进展</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>系统级别语言以其高性能高效率而广泛应用于各类软件的编写，但同时也饱受内存时间安全问题所扰。 近些年来，像释放后重用漏洞这类的内存时间安全漏洞数量逐渐增多，对软件安全造成了很大的威胁。因而，这些年来涌现了许多关于保障内存时间安全的研究。本文通过归纳总结不同内存时间安全防御的研究，并探讨内存时间安全的未来研究方向。</p>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>内存安全问题一直都是计算机安全领域所关注的重点问题。据MITRE统计[1]，2019年最高危的前十个CWE中，内存安全类漏洞占了约50%。而导致内存安全漏洞泛滥的原因是大量的软件都是基于不安全的语言，如C和C++。这类语言具有对内存直接操作的特性，从而提高了编程效率和程序的性能，但也正因为能对内存操作，所以引入了许多内存安全问题。而且这类语言编写的代码存在于各类系统级软件中，如操作系统、虚拟机等。用其他相对安全的语言是很难替代这类语言完成这些系统级软件的编写的，因为缺乏对于计算机底层操作的支持。此外，现存的大量软件都存在这类安全问题，重写这些软件也是不太现实的。</p>
<p>内存安全可以分为内存空间安全和内存时间安全。由于内存空间漏洞具有危害大，容易利用等特点，现阶段关于内存空间安全的研究较为成熟。相比之下，关于内存时间安全的研究相对较少。内存时间安全问题主要是由Use After Free（UAF）和Double Free等指针状态类漏洞导致的。攻击者可以利用这样的UAF漏洞操作数据输入来获取整个程序的控制权甚至是整个系统[2]。对于内存空间安全漏洞，使用边界检查的机制能很大程度上缓解，但边界检查对于UAF漏洞无效。UAF漏洞存在因此，未来的计算机系统不仅要考虑内存空间安全，也要考虑到内存时间安全，才能构建完整的安全体系结构。</p>
<p>随着这些年关于内存时间安全的研究增多，要区分不同研究的优劣成了一个相对比较难的问题。因此，本文旨在系统化地整理和评估近些年提出的解决方案。本文首先描述UAF漏洞利用的原理，分析UAF漏洞利用的条件，并根据该条件划分防御方法并对其进行评估。防御方法的评估基于健壮性，兼容性和性能开销。最后本文基于该评估，总结各方法的优劣并提出未来内存时间安全防御的可能研究方向。</p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h2 id="悬垂指针与UAF漏洞的关系"><a href="#悬垂指针与UAF漏洞的关系" class="headerlink" title="悬垂指针与UAF漏洞的关系"></a>悬垂指针与UAF漏洞的关系</h2><p>悬垂指针指的是指向某对象的指针，当对象释放后，该指针指向的是内存是不确定的。所以称该指针为悬垂指针。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/wps1.jpg" alt="img"> </p>
<p>图1 Use After Free 漏洞示例代码</p>
<p>UAF漏洞本质上是悬垂指针的重引用。图1展示了一个UAF漏洞代码。其可简化为三步：第一，程序先是在堆上为<strong>buf1</strong>分配了<strong>size</strong>大小的空间，之后释放<strong>buf1</strong>，使得<strong>buf1</strong>成为悬垂指针，即其指向的内存数据是不可预测的。这块内存有可能被堆管理器回收，也可能被其他数据占用，存在着很大的不可预测性。第二，程序为<strong>buf2</strong>在堆上分配与<strong>buf1</strong>相等大小的空间，这里由于<strong>buf1</strong>的释放和<strong>buf2</strong>的分配内存的时间间隔较近，且分配的内存大小一致，根据内存分配的原则，有很大可能使得<strong>buf2</strong>分配到已释放的<strong>buf1</strong>的内存位置上去。第三，重引用悬垂指针<strong>buf1</strong>。这里为其赋值为<strong>“hack”</strong>字符串，由于<strong>buf2</strong>和<strong>buf1</strong>指向同一块内存，将会导致<strong>buf2</strong>的值也被篡改为“<strong>hack”</strong>。</p>
<h2 id="内存时间安全漏洞利用方式"><a href="#内存时间安全漏洞利用方式" class="headerlink" title="内存时间安全漏洞利用方式"></a>内存时间安全漏洞利用方式</h2><p>内存时间安全威胁主要由UAF漏洞导致，但也包括双重释放漏洞[3]。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/wps2.jpg" alt="img"> </p>
<p>图2 Use After Free 攻击图解</p>
<p>利用UAF漏洞实施攻击的核心思路是攻击者在已释放区域放置精心构造的数据，当程序重引用悬垂指针时，就会触发攻击。所以如果攻击者在释放区域设置一个虚拟函数表指针，当内存重引用悬垂指针时，就会跳转到攻击者想要执行的代码位置处执行代码，从而使攻击者劫持程序的控制流,如图2所示。另一个利用UAF漏洞的例子是攻击者将用于检查访问合法的root权限标志放在已释放区域，就可以实现权限提升攻击。而且如果漏洞存在于内核中，攻击者将能控制整个系统。此外，还可以利用这类漏洞篡改关键数据，也可以实现非控制数据攻击。因此，UAF漏洞可以作为多种攻击的突破口。</p>
<p>双重释放漏洞，则是UAF漏洞的一个特例，只是用悬垂指针来调用<strong>free</strong> 函数。在这种案例下，由攻击者控制内容的新对象会被误认为是堆的元数据，从而可以写任意内存[3]。</p>
<p>总之，成功利用UAF漏洞实施攻击需要三个必不可少的元素：一是悬垂指针的产生，二是分配到了悬垂指针所指向的内存空间的对象，三是重引用悬垂指针的指令（读或写）。</p>
<h2 id="内存时间安全的挑战"><a href="#内存时间安全的挑战" class="headerlink" title="内存时间安全的挑战"></a>内存时间安全的挑战</h2><p>图1显示的代码只是一种简单的UAF漏洞利用方式，现实生活中的UAF漏洞要更复杂的多。首先，UAF漏洞利用需要的三个元素可以存在于不同的函数和模块中。其次，实际应用运行时，这些操作可能会在不同的线程中发生。比如浏览器需要处理来自JavaScript或者DOM树的各种事件，UI应用需要处理用户产生的事件，然后服务器端还要处理大量的用户请求。基于如此复杂的场景，导致程序员很难避免这类漏洞。最后，指针还可以传播复制到程序的各种地方，加大了悬垂指针发现的难度。</p>
<p>而要放弃使用C或C++这种语言也是不现实的，因为许多底层的系统的实现需要这类语言操作内存的特性。况且，现存的许多软件都是基于这类语言编写的。因此，内存时间安全保障的机制必不可少。</p>
<h1 id="内存时间安全防御方法"><a href="#内存时间安全防御方法" class="headerlink" title="内存时间安全防御方法"></a>内存时间安全防御方法</h1><p>要成功利用UAF漏洞实现攻击需要三个要素：悬垂指针、复用已释放的内存，重引用悬垂指针的指令。因此，只要消除其中的某个元素就能达到内存时间安全防御的目的，于是主要方法可分为以下三类：基于消除悬垂指针的方法，基于内存分配的方法，基于防止重引用的方法。实际上有些方法消除了其中的两个或所有元素，这里按时间顺序归类，即某方法消除了第二，三个元素，则将其归为第二类方法。</p>
<h2 id="基于消除悬垂指针的方法"><a href="#基于消除悬垂指针的方法" class="headerlink" title="基于消除悬垂指针的方法"></a>基于消除悬垂指针的方法</h2><p>基于指针的方法的核心思路是两步：第一，找到悬垂指针；第二，悬垂指针置空。这类方法有DangNull[4]、FreeSentry[5]、DangSan[6]和PSweeper[7]。DangNull针对内存时间安全的根本原因——悬垂指针，通过指针追踪对象的信息，当对象被释放时，将其指针置空，从而避免后续的潜在威胁。但是，DangNull只能追踪堆上对象的指针，而无视了栈和全局内存上的。FreeSentry改善了这点，可以追踪所有的指针，并降低了运行开销，但是其不支持多线程程序。而多线程程序如服务器，浏览器是UAF漏洞存在的主要地方。因此，研究者基于前面两个的研究，提出了DangSan，使得其可以支持多线程应用。但以上三种方法因为需要维护指针和对象的关系，而导致运行开销很大，而且需要在许多地方加锁来避免应用多线程的竞争。基于这些缺点，PSweeper诞生了，其在并发线程中去迭代地搜索悬垂指针，并使用对象源追踪技术来无效化悬垂指针。PSweeper使用空闲的CPU核来减少安全检查的延迟，相比上面三种方法消耗的CPU资源会更多，但会更加有效。</p>
<p>以上方法都是基于编译器来实现的方法，此外也有基于硬件来清洗悬垂指针的方法，比如BOGO[8]、CHERIvoke[9]。BOGO基于Intel的MPX改进，通过复用MPX的元数据来验证已释放区域的悬垂指针，使之能保护内存时间安全。但是MPX存在开销大、不支持多线程、与ISA组件存在冲突等诸多问题，使得BOGO能否应用实际成了问题。不过这种基于已有硬件来扩展的思路启发了CHERIvoke。其基于CHERI[10]架构，利用内存标记的技术，仅使用1bit的标签元数据，就能在运行时清扫内存将悬垂指针无效化。</p>
<h2 id="基于内存分配的方法"><a href="#基于内存分配的方法" class="headerlink" title="基于内存分配的方法"></a>基于内存分配的方法</h2><p>通过避免对象分配复用已被释放对象的内存，来防止UAF漏洞的利用。所以这类方法有Cling[11]、DieHarder[12]和Address Sanitizer[13]，其通过修改计算机内存分配的机制，来避免恶意对象复用已释放对象内存空间。</p>
<p>防止对象复用已释放对象内存的一种简单思路是从不使用已释放对象的内存，但如果遇到频繁释放对象内存的程序，就会造成内存的严重浪费。而Cling通过限制内存分配，只允许相同类型的对象之间重用地址空间，因此降低了性能和内存开销，并且保证了类型安全内存复用，防止了大部分的悬垂指针攻击，但不能防止攻击者重用本地堆栈分配的对象来实施攻击。DieHarder和Address Sanitizer都使用了一种延迟-复用技术，防止分配的新对象的内存空间是刚释放的旧对象的空间。但DieHarder与Address Sanitizer的目的不同，DieHarder的目的是为了提供系统运行时的防御，而Address Sanitizer更多是在系统运行前作为调试工具，检测出漏洞。这些系统能够发现非人为的UAF操作，但不适合检测蓄意的攻击[4]，比如通过堆喷射来绕过这种防御机制。</p>
<p>此外，也有使用基于页表的技术进行分配内存，如Oscar[14]。其将每个分配的对象放在不同的虚拟页中，当一个对象被释放了，就修改相应的虚拟页的权限，使得悬垂指针无法访问被释放后的内存地址。这种基于页表的方式当分配内存大时，性能开销比较小。但是遇到频繁的小内存分配就会加大性能和内存开销，这是因为每次分配都会赋予一个虚拟页，这就导致TLB的压力，从而造成性能的下降。</p>
<p>除了以上使用软件方式实现的内存分配，使用硬件方法的有REST[15]和Califorms[16]。</p>
<p>REST用8-64B的令牌填充所有释放的内存，并将其置于独立的隔离池中。直到空闲的内存池消耗殆尽，这些隔离的内存才用于重新分配。因此，由于已释放的内存处于黑名单中，此时通过悬垂指针访问都是无效的，从而保证了内存时间安全。Califorms也是使用相同的方式，只不过元数据的粒度处于字节级别，是基于REST方法的改进，整体开销更小，保护面更广，能保护对象内安全（intra-object security）。</p>
<h2 id="基于检测重引用的方法"><a href="#基于检测重引用的方法" class="headerlink" title="基于检测重引用的方法"></a>基于检测重引用的方法</h2><p>这类方法聚焦于检测UAF利用的第三步，也是实质上对内存时间安全产生危害的UAF操作，如图1的第11行。这类方法的思路类似锁和钥匙，每次分配的内存都会赋予一个锁，并且每个有效的指向该内存的指针也会赋予一个匹配的钥匙。只有相互匹配的锁与钥匙才能进行合法的操作。而当内存重分配以后，对应的锁也就变了。因此，如果重引用悬空指针的话，就可以视为使用一把旧钥匙去开一把新锁，从而被系统检测出来重引用悬空指针这一操作。</p>
<p>基于软件方法实现这一思路的有CETS[17]和Undangle[18]。</p>
<p>CETS，使用基于身份的方案，为每一个指针分配一个标签，并在指针被重引用时检查标签和其分配的区域，若不匹配则内存访问失败，从而避免悬空指针的重引用。为了应对指针运算的情况，CETS使用了污点传播，使得传播的指针继承了原有的指针元数据，但是事实上传播的指针不一定和原来指针指向相同的对象，这就导致这种方法的假阳性比较高。因此，研究者提出了基于污点追踪的方法Undangle，其从指针分配的位置开始跟踪，避免了当指针以类型不安全的形式复制时丢失元数据的情况，从而达到比较好的保护效果。</p>
<p>然而基于软件方法实现这一思路需要在每次内存访问时都要进行一次检测，从而导致性能开销很大，更适合作为调试工具，而非运行时系统的防御。因此研究者开始着力于减小性能开销，从而诞生了基于硬件的实现方法，诸如Watchdog[19]和WatchdogLite[20]。</p>
<p>Watchdog的检测重引用悬空指针操作和CETS相似，主要是在内存访问检测做了很多优化，包括使用微指令注入、元数据编码、ISA辅助识别和寄存器重命名技术。虽然极大地降低了运行性能开销，然而付出的代价是硬件的复杂性过高。于是Watchdog的研究者提出了WatchdogLite这一改进版本。WatchdogLite通过硬件优化来利用编译器检测指针，从而不需要添加任何新的硬件来保存元数据的状态，降低了硬件复杂性同时也保证较低的运行开销。</p>
<h1 id="未来研究方向"><a href="#未来研究方向" class="headerlink" title="未来研究方向"></a>未来研究方向</h1><p>表1总结了上述的方法，其内存开销和运行开销都是基于SPEC 2006测试的。下面将对这三类方法进行讨论。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20210418213043430.png" alt="image-20210418213043430"></p>
<p>在消除悬垂指针方法中，又可按照具体实现分为基于硬件和基于软件。基于软件的方法通常是维护指针和对象的关系来置空指针，而要维护指针和对象的关系，就需要存储比较复杂的元数据，从而导致了内存开销过大。文中提到的基于硬件的方法都是基于已提出的硬件结构稍加扩展来保护内存时间安全的。虽然性能开销和内存开销都要相对软件方法优越，但能否应用实际存在比较大的考量。</p>
<p>内存分配方法中，实现方式也可以分为硬件和软件。早期的该类方法主要目的是以低开销的方式增加漏洞利用难度。除了Address Sanitizer是作为检测工具，所以牺牲了运行开销。近期研究使用基于页表的技术，兼容性好，但开销稍微大一些。基于硬件的方法主要使用的隔离缓冲区的技术，本质上也是延迟复用已释放内存的区域。这类方法的优势是可以结合其他技术，构成更强的内存安全防护体系。</p>
<p>检测重引用的方法中，通常需要跟踪指针动态。而指针存在很多不确定性，因为其可能被复制多份传播到程序各处。要提高跟踪准确率，就需要相应的开销来维持，否则只能降低开销，来保证部分安全。该类方法和消除悬垂指针的方法也有些相似，都需要追踪指针动态，不同的是两种方法在指针重引用时做的操作不同，前者是做检测，后者是消除悬空指针。从而导致检测重引用的方法主要花费开销在检测上。</p>
<p>总体来看，基于硬件的方法和基于软件的方法在安全上效果相差不大，但硬件方法在减小开销上更胜一筹，而软件方法在兼容性上具有优势。所以未来的研究可以从软硬件协同防御入手，基于兼容性较好的硬件扩展，来完善硬件缺失的安全功能，使得研究能够应用实际。此外，由于UAF漏洞广泛存在于多线程应用中，而这些研究中只有少部分支持多线程应用。因此，今后的内存时间安全研究也应考虑支持多线程。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文针对悬垂指针引发的UAF漏洞，综述了内存时间安全的研究现状。首先简述如何利用UAF漏洞实施攻击，突出了UAF漏洞利用的三要素。并以此为据，将内存时间安全研究分为三类，论述了这三类方法的基本思路。接着，基于安全、运行开销、兼容性这三点对各方法进行评估，并提出未来内存时间安全可能的研究方向。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] “2019 CWE Top25 Most Dangerous Software Errors” MITRE, <a href="https://cwe.mitre.org/top25/archive/2019/2019_cwe_top25.html">https://cwe.mitre.org/top25/archive/2019/2019_cwe_top25.html</a>, Sept. 2019.</p>
<p>[2] Xu, Wen, et al. “From collision to exploitation: Unleashing use-after-free vulnerabilities in linux kernel.” Proceedings of the 22nd ACM SIGSAC Conference on Computer and Communications Security. 2015.</p>
<p>[3] Szekeres, Laszlo, et al. “Sok: Eternal war in memory.” 2013 IEEE Symposium on Security and Privacy. IEEE, 2013.</p>
<p>[4] Lee, Byoungyoung, et al. “Preventing Use-after-free with Dangling Pointers Nullification.” NDSS. 2015.</p>
<p>[5] Younan, Yves. “FreeSentry: protecting against use-after-free vulnerabilities due to dangling pointers.” NDSS. 2015.</p>
<p>[6] Van Der Kouwe, Erik, Vinod Nigade, and Cristiano Giuffrida. “Dangsan: Scalable use-after-free detection.” Proceedings of the Twelfth European Conference on Computer Systems. 2017.</p>
<p>[7] Liu, Daiping, Mingwei Zhang, and Haining Wang. “A robust and efficient defense against use-after-free exploits via concurrent pointer sweeping.” Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security. 2018.</p>
<p>[8] Zhang, Tong, Dongyoon Lee, and Changhee Jung. “BOGO: buy spatial memory safety, get temporal memory safety (almost) free.” Proceedings of the Twenty-Fourth International Conference on Architectural Support for Programming Languages and Operating Systems. 2019.</p>
<p>[9] Xia, Hongyan, et al. “CHERIvoke: Characterising Pointer Revocation using CHERI Capabilities for Temporal Memory Safety.” Proceedings of the 52nd Annual IEEE&#x2F;ACM International Symposium on Microarchitecture. 2019.</p>
<p>[10] Watson, Robert NM, et al. “Cheri: A hybrid capability-system architecture for scalable software compartmentalization.” 2015 IEEE Symposium on Security and Privacy. IEEE, 2015.</p>
<p>[11] Akritidis, Periklis. “Cling: A Memory Allocator to Mitigate Dangling Pointers.” USENIX Security Symposium. 2010.</p>
<p>[12] Novark, Gene, and Emery D. Berger. “DieHarder: securing the heap.” Proceedings of the 17th ACM conference on Computer and communications security. 2010.</p>
<p>[13] Serebryany, Konstantin, et al. “AddressSanitizer: A fast address sanity checker.” Presented as part of the 2012 {USENIX} Annual Technical Conference ({USENIX}{ATC} 12). 2012.</p>
<p>[14] Dang, Thurston HY, Petros Maniatis, and David Wagner. “Oscar: A practical page-permissions-based scheme for thwarting dangling pointers.” 26th {USENIX} Security Symposium ({USENIX} Security 17). 2017.</p>
<p>[15] Sinha, Kanad, and Simha Sethumadhavan. “Practical memory safety with REST.” 2018 ACM&#x2F;IEEE 45th Annual International Symposium on Computer Architecture (ISCA). IEEE, 2018.</p>
<p>[16] Sasaki, Hiroshi, et al. “Practical byte-granular memory blacklisting using califorms.” Proceedings of the 52nd Annual IEEE&#x2F;ACM International Symposium on Microarchitecture. 2019.</p>
<p>[17] Nagarakatte, Santosh, et al. “CETS: compiler enforced temporal safety for C.” Proceedings of the 2010 international symposium on Memory management. 2010.</p>
<p>[18] Caballero, Juan, et al. “Undangle: early detection of dangling pointers in use-after-free and double-free vulnerabilities.” Proceedings of the 2012 International Symposium on Software Testing and Analysis. 2012.</p>
<p>[19] Nagarakatte, Santosh, Milo MK Martin, and Steve Zdancewic. “Watchdog: Hardware for safe and secure manual memory management and full memory safety.” 2012 39th Annual International Symposium on Computer Architecture (ISCA). IEEE, 2012.</p>
<p>[20] Nagarakatte, Santosh, Milo MK Martin, and Steve Zdancewic. “Watchdoglite: Hardware-accelerated compiler-based pointer checking.” Proceedings of Annual IEEE&#x2F;ACM International Symposium on Code Generation and Optimization. 2014.</p>
]]></content>
      <tags>
        <tag>survey</tag>
      </tags>
  </entry>
  <entry>
    <title>【论文笔记】FishFuzz:Throwing Larger Nets to Catch Deeper Bugs</title>
    <url>/2022/10/24/FishFuzz%20Throwing%20Larger%20Nets%20to%20Catch%20Deeper%20Bugs/</url>
    <content><![CDATA[<h1 id="FishFuzz-Throwing-Larger-Nets-to-Catch-Deeper-Bugs"><a href="#FishFuzz-Throwing-Larger-Nets-to-Catch-Deeper-Bugs" class="headerlink" title="FishFuzz: Throwing Larger Nets to Catch Deeper Bugs"></a>FishFuzz: Throwing Larger Nets to Catch Deeper Bugs</h1><p>开源于：<a href="https://zenodo.org/record/6405418">https://zenodo.org/record/6405418</a></p>
<h2 id="论文基本信息"><a href="#论文基本信息" class="headerlink" title="论文基本信息"></a>论文基本信息</h2><p>发表年份：2022<br>发表会议或期刊（简称，CCF级别）：预印版<br>论文标题（论文简称）：FishFuzz: Throwing Larger Nets to Catch Deeper Bugs<br>论文作者所在团队：网络中心、兰州理工、西电、海南，EPFL<br>论文一句话概述：论文提出XX方法，解决了XX问题。<br>论文实验情况：实验工具（是否开源），实验测试集（是否开源），实验环境，实验规模，简要过程</p>
<h2 id="论文概述"><a href="#论文概述" class="headerlink" title="论文概述"></a>论文概述</h2><p>定向模糊测试是在开发中发现漏洞的一种标准方法。模糊测试会执行许多输入来最大化测试的代码。最近，定向模糊测试提出了一种策略，不仅仅是最大化覆盖率。而是让测试导向特定区域。定向模糊测试有两个阶段，exploration（探索有趣的区域）和exploitation（触发漏洞）。目前的定向模糊测试的探索阶段都是用覆盖率来引导，exploitation阶段是通过切换不同目标来间接实现的。具体来说，文章发现了现有定向模糊测试的两个局限。（i）距离指标在对多条路径和多个目标进行计算的时候不是很准确。（2）分配能量到种子的粒度比较粗糙，没有考虑调整目标的优先级。</p>
<p>文章提出了FishFuzz，灵感来源捕鱼。首先放一个大网，获取比较高的覆盖率，然后慢慢收网来最大化抓到的鱼。FishFuzz的核心是两个理念：（1）一种新的距离指标，准确率和目标的多少无关。（2）动态的目标排名，能够自动排除已探索过很多次的target。这个策略让FishFuzz能够无缝从单目标到多目标的切换，并且能够动态地在exploration和exploitation中切换。</p>
<p>评估部分，将所有的sanitizer打的标签当作是target。并与三个DGF和两个CGF作笔记，结果表示，FishFuzz能够实现更高的覆盖率，并且复现现有的bug更快，最后在44个程序中发现了25个新的bug。</p>
<h2 id="研究背景"><a href="#研究背景" class="headerlink" title="研究背景"></a>研究背景</h2><p>问题是什么？</p>
<p>现有的定向模糊测试存在以下两个问题：</p>
<ul>
<li>种子爆炸：fuzzing的过程提供了大量的种子，放在一个池子里。导致很多好的种子没有得到足够的重视。</li>
<li>不准确的距离度量：对大量目标计算距离会引入不准确性，也是现有定向模糊测试的种子调度算法无法处理的。</li>
</ul>
<p>意义是什么？</p>
<p>可以处理大规模目标，而不会丢失准确性。</p>
<h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>相关工作主要介绍了定向模糊测试和多阶段模糊测试。</p>
<h3 id="定向模糊测试"><a href="#定向模糊测试" class="headerlink" title="定向模糊测试"></a>定向模糊测试</h3><p>定向模糊测试是模糊测试的一个分支，专门去测试给定的区域。AFLGO将种子到目标的距离建模为调和平均距离。然而，AFLGo对于大规模的目标会丢失准确性。Hawkeye和FuzzGuard都尝试处理距离计算的间接调用问题，其中hawkey使用重量级的静态分析，Fuzzguard使用深度学习过滤不可达的输入。</p>
<p>后面的DGF扩展性会更好一些。比如ParmeSan和SAVIOR。他们两个把target当成是所有sanitizer打上的标签。此外，SAVIOR也使用了开销比较大的可达性分析来选择有趣的输入。但他们都有AFLGo的局限性，就是把种子到目标的距离折叠为一个标量。</p>
<p>CAFL的目标是给定一个crash，然后生成一个PoC。但CAFL只考虑一个目标。AFLChurn通过分析github仓库选择可能存在bug的位置去测试。这和本文算是一个正交的工作。Beacon使用复杂的静态分析来移除不可达的路径，从而提高了exploration的效率。这和fishfuzz提升的维度不一样。</p>
<h3 id="多阶段模糊测试"><a href="#多阶段模糊测试" class="headerlink" title="多阶段模糊测试"></a>多阶段模糊测试</h3><p>多阶段的模糊测试使用exploration和exploitation来到达和触发多个目标。AFLFast使用马尔科夫链来概率性地选择种子来提高覆盖率。FairFuzz使用一种新的变异策略和种子选择方式来命中稀有的分支。他们的贡献是提高代码覆盖率。而fishfuzz是最大化触发的目标。Yue将适应性能量调度和博弈论结合起来，来防止测试没用的种子。wang基于软件分析选择有趣的目标，然后结合一种新的队列策略。然而，他们的方法只考虑了时间不变的target，也就不会自适应地调整fuzz的能量到更有可能发现漏洞的位置。FishFuzz的队列切换方式是自适应的，而且可以被用来提高wang的工作。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>给定一个目标程序，会编译并用sanitizer插桩，并且提取一些有用的信息。整体流程和通常的模糊测试差不多。主要修改的地方是距离指标和种子选择的实现。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20221023182021870.png" alt="image-20221023182021870"></p>
<h3 id="Program-Preparation"><a href="#Program-Preparation" class="headerlink" title="Program Preparation"></a>Program Preparation</h3><p>在程序分析阶段，主要是提取sanitizer插入的target。但由于有些target可能会是不可达的。现有的方法使用静态分析来剔除，但静态分析有可能会误删。因此，FishFuzz将所有的目标都视为有效地，通过动态排名来过滤不理想的目标。</p>
<p>在编译阶段，提取了控制流图和调用图，此时的图没有考虑间接调用。然后，FishFuzz依赖CFG和CG的过程间距离来选择靠近目标的种子。这些操作都是基于LLVM IR上做的。</p>
<h3 id="Queue-Culling-Algorithm"><a href="#Queue-Culling-Algorithm" class="headerlink" title="Queue Culling Algorithm"></a>Queue Culling Algorithm</h3><p>队列选择算法灵感源于捕鱼技术。在fuzzing的初期，Fishfuzz采取exploration模式，类似广撒网。当没有发现新的函数时，FishFuzz会去聚焦于最大化到达的目标，类似收网。当到达了足够多的目标时，cull的逻辑改变，尝试去触发有趣的目标（尽可能地抓到更多的鱼）。由于每个步骤都需要不同的指标（到达函数的数量，到达目标的数量，触发目标的数量），所以也像别的工作一样分阶段来做。</p>
<p>主要分为三个阶段：Inter-function exploration，intra-function exploration ，exploitation。</p>
<ul>
<li><p>inter-function exploration：到达感兴趣的函数。</p>
</li>
<li><p>intra-funcion exploration：函数内测试，主要是去尽可能地命中更多的目标。</p>
</li>
<li><p>exploitation：尽可能地触发更多可以到达目标。</p>
</li>
</ul>
<p>他们的切换过程如下图所示，当没有发现新的函数的时候，就会从inter-function转为intra-function。当发现了新的函数，就会从intra-function转为inter-function。如果没有到达新的target，就会从intra-function切换到exploitation阶段。没有触发新的target，就会从exploitation回到intra-function。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20221024210010657.png" alt="image-20221024210010657"></p>
<p>inter-function exploration过程中，给定一个种子队列和一个函数集合。对于那些经过未探索的函数，并且包含目标的种子，将favor设为1。在把favored的种子提交给程序后，FishFuzz更新探索过的函数列表，并且重复这个过程。getClosestSeedToFun会去找到离目标函数f最近的种子。</p>
<p>exploitation过程中，FishFuzz会尝试触发已到达的目标。他的思路是通过不同的种子来命中同一目标，能够增加发现bug的概率。首先，使用那些能到达的目标。在trgs_to_visit中，选择前20%命中的目标。对于每个合适的目标，getFastestSeedToTarget返回最快到达t的种子s。这个过程中，有很大的概率选择命中目标的种子（seed target distance&#x3D;0）。</p>
<h3 id="距离指标"><a href="#距离指标" class="headerlink" title="距离指标"></a>距离指标</h3><p>距离指标分为：</p>
<ul>
<li>静态函数距离</li>
<li>动态种子到函数的距离</li>
<li>动态种子到多目标的距离</li>
</ul>
<p>静态函数距离指的是调用图上两个函数最短的边的数量。</p>
<p>动态种子到函数的距离，分为以下两种情况，如果种子经过了目标函数，距离则为0，如果没有经过，距离为最近的那个函数到种子的距离。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20221025105710952.png" alt="image-20221025105710952"></p>
<p>动态种子到多个目标的距离，是由多个种子到各个目标的距离组成的一个向量。会在这个函数用到getFastestSeedToTarget</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20221025105651544.png" alt="image-20221025105651544"></p>
<p>种子到单个目标的距离为前面的距离，加上一个目标是否被触发的条件。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20221025105750760.png" alt="image-20221025105750760"></p>
<p>这里很奇怪，给了一个向量，要怎么比距离？向量的比较方式，论文中没有说明。</p>
<p>关于间接调用的问题。种子到函数的距离被表示为最小函数的距离，作者认为这种方法可以找到近似最佳的结果。当一个种子遍历到间接调用时，fishfuzz可以使用附近的函数来估计种子执行路径到目标函数的距离。如果一个函数没有和其他函数直接联系，模糊器要么生成一个到达该函数的种子，要么生成一个无法到达的种子。实际上，这种方法和以前一个使用fuzzing来探索间接调用的工作相同。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>基于AFL 2.57b实现，插桩使用的是LLVM 12.0.1。实现函数内探索和利用阶段，用了2500行的代码。对于插桩部分，代码有1500行。</p>
<p>源码和复现相关的材料在被接收后就会开源。目前已开源在：<a href="https://zenodo.org/record/6405418">https://zenodo.org/record/6405418</a></p>
<h2 id="实验结果及分析"><a href="#实验结果及分析" class="headerlink" title="实验结果及分析"></a>实验结果及分析</h2><p>回答6个问题：</p>
<ul>
<li>FishFuzz能到达多少目标？</li>
<li>FishFuzz能够平衡能量吗？</li>
<li>FishFuzz发现漏洞的效率怎么样？</li>
<li>FishFuzz能发现新漏洞吗？</li>
<li>FishFuzz是如何重新分配exploration和exploitation？</li>
<li>其他的fuzzer能够从我们的策略受益吗？</li>
</ul>
<p>对比工具选择了TortoiseFuzz，ParmeSan和SAVIOR。同时AFL++和AFL也被作为baseline。</p>
<p>benchmark方面，选择了TortoiseFuzz、SAVIOR和ParmeSan测试的程序。TortoiseFuzz用的程序会被ASAN插桩，在文章中叫ASAN benchmark。SAVIOR测的程序只包含UBSan sanitizer，就叫UBSAN benchmark。</p>
<h3 id="RQ1"><a href="#RQ1" class="headerlink" title="RQ1"></a>RQ1</h3><p>这个实验评估的指标主要是覆盖率和目标覆盖率。</p>
<p>对比ParmeSan和TortoiseFuzz。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20221023163233076.png" alt="image-20221023163233076"></p>
<p>和SAVIOR进行对比的结果。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20221023163242967.png" alt="image-20221023163242967"></p>
<h3 id="RQ2"><a href="#RQ2" class="headerlink" title="RQ2"></a>RQ2</h3><p>这个部分评估FishFuzz为目标重新分配能量的能力。与AFL进行对比，跑3轮24小时。下面的图展示了FishFuzz尝试去分配能量给那些测试比较少的target。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20221025113308569.png" alt="image-20221025113308569"></p>
<h3 id="RQ3"><a href="#RQ3" class="headerlink" title="RQ3"></a>RQ3</h3><p>这个实验中是评估exploitation阶段触发漏洞的能力。主要是比发现的漏洞的数量。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20221025114407436.png" alt="image-20221025114407436"></p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20221025114416052.png" alt="image-20221025114416052"></p>
<h3 id="RQ4"><a href="#RQ4" class="headerlink" title="RQ4"></a>RQ4</h3><p>找了28个顶会里用的程序，对于每个程序用ASan和UBSan插桩，用一周的时间去找漏洞。最后发现了25个新的漏洞，其中18个被确认为CVE。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20221025114530188.png" alt="image-20221025114530188"></p>
<h3 id="RQ5"><a href="#RQ5" class="headerlink" title="RQ5"></a>RQ5</h3><p>这个实验主要是看三个阶段的覆盖率，触发的目标和轨迹。下面这个图展示了各个fuzzer阶段覆盖的边的情况。蓝色是inter-function，绿色是intra-function，红色是exploitation。覆盖率在exploration阶段的时候，快速上升。在exploitation（红色）阶段，覆盖率趋于平稳。两种exploration阶段在开始阶段比较频繁出现，exploitation阶段则倾向于在后期出现。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20221025114940865.png" alt="image-20221025114940865"></p>
<h3 id="RQ6"><a href="#RQ6" class="headerlink" title="RQ6"></a>RQ6</h3><p>和其他fuzzer结合的能力如何，明显比afl和qsym的相性好。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20221025114612407.png" alt="image-20221025114612407"></p>
<h2 id="论文总结"><a href="#论文总结" class="headerlink" title="论文总结"></a>论文总结</h2><h2 id="自己的感受"><a href="#自己的感受" class="headerlink" title="自己的感受"></a>自己的感受</h2><p>读完论文后，自己的想法<br>论文有哪些优点和亮点<br>论文还有哪些问题没有解决<br>有哪些启发，可以继续探索</p>
<p>作者很贴心地附上了画韦恩图的工具：jvenn: an interactive venn diagram viewer</p>
<p>tortoisefuzz我得看看，之前给我的印象并不是定向模糊测试。</p>
<p>Mann-Whitney U test，这个概念在windranger中也看到过，当时没有特别注意。有时间再搜搜看。</p>
<p>文章留了很多阈值调参来作为后续的工作。阈值是不是也是程序无关的呢？</p>
<p>arxiv上的写作上还有些瑕疵。</p>
]]></content>
      <tags>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title>【论文笔记】SyML, Guiding Symbolic Execution Toward Vulnerable States Through Pattern Learning</title>
    <url>/2021/12/06/SyML%20Guiding%20Symbolic%20Execution%20Toward%20Vulnerable%20States%20Through%20Pattern%20Learning/</url>
    <content><![CDATA[<h1 id="SyML-Guiding-Symbolic-Execution-Toward-Vulnerable-States-Through-Pattern-Learning"><a href="#SyML-Guiding-Symbolic-Execution-Toward-Vulnerable-States-Through-Pattern-Learning" class="headerlink" title="SyML: Guiding Symbolic Execution Toward Vulnerable States Through Pattern Learning"></a>SyML: Guiding Symbolic Execution Toward Vulnerable States Through Pattern Learning</h1><p>RAID 2021</p>
<p>开源：<a href="https://github.com/ucsb-seclab/syml">https://github.com/ucsb-seclab/syml</a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在二进制程序里探索很多的执行路径对于发现新的漏洞是很重要的。动态符号执行能够触发复杂的输入条件，并且能够精确地探索程序，同时提供crash的可复现性和语义信息。然而，要扩展这种分析方式到复杂的二进制程序里是很困难的。目前的方法有很严重的路径爆炸问题。尽管现在有很多方式提出来解决这个问题，但现阶段这个挑战仍然很难解决，并且通过这种技术发现的漏洞都很少。</p>
<p>这篇文章的工作重心就是尝试去解决符号执行的路径爆炸问题。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="数据集（放实验讲吧）"><a href="#数据集（放实验讲吧）" class="headerlink" title="数据集（放实验讲吧）"></a>数据集（放实验讲吧）</h3><p>选择CGC数据集，包含232个漏洞程序，其中有超过400个漏洞输入能够触发各种漏洞。然而，由于DSE引擎的问题，有些漏洞无法分析。最后就只剩下包含120多个漏洞的75个二进制可以用。</p>
<p>作者还列举了选测试集的一些标准，包含volume、variety、consistency、complexity、confidence这些指标。</p>
<h3 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h3><p>整体可以分为特征提取、数据清洗、训练模型、导向符号执行这几个部分。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20211206153130549.png" alt="image-20211206153130549"></p>
<h4 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h4><p>特征提取包含三个步骤：</p>
<ol>
<li>具体追踪<ul>
<li>用会崩溃的输入在QEMU里运行漏洞二进制，收集导致crash的trace。</li>
</ul>
</li>
<li>静态分析<ul>
<li>收集全局的静态信息，包括CFG等，来支持后续的分析</li>
</ul>
</li>
<li>动态符号追踪<ul>
<li>然后沿着记录的trace去符号执行</li>
</ul>
</li>
</ol>
<p>提取的特征如下：</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20211207195051499.png" alt="image-20211207195051499"></p>
<h4 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h4><p>去除缺失值、异常值、离群值和重复值</p>
<h4 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h4><p>采用四个指标来评估分类模型：</p>
<ul>
<li>F1-score：</li>
<li>准确率</li>
<li>trace覆盖率</li>
<li>判分时间</li>
</ul>
<h4 id="导向符号执行"><a href="#导向符号执行" class="headerlink" title="导向符号执行"></a>导向符号执行</h4><p>由于预测不一定准确，并且搜索空间很大，因此需要使用一些策略来最大化利用状态预测的结果。</p>
<p>探索策略如下：</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20211206162035958.png" alt="image-20211206162035958"></p>
<p>性能考量</p>
<ol>
<li>初始开销。为了避免在探索阶段引入额外开销，这里提前从上下文信息里计算某些特征来作为初始开销，比如connectivity，centrality，function_size，function complexity，components information，community partition这些。</li>
<li>特征数目。特征数目太多会导致计算开销增加或者模型准确率降低。因此，使用information gain来手动检查所有的特征，确保他们都是相关的特征。</li>
</ol>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><h3 id="模型准确度和特征评估。"><a href="#模型准确度和特征评估。" class="headerlink" title="模型准确度和特征评估。"></a>模型准确度和特征评估。</h3><p>选择了几个常见的机器学习模型来进行训练。所有的模型都是调用scikit-learn来实现的。下面的数据都是使用交叉验证来验证的，在每次验证回合，将一个二进制取出来，然后其他的二进制用来训练，得到F1，准确率等指标。下面的表格基本说明他提的特征是没啥问题的。</p>
<p>实际上他的特征也不是一次就提取正确的。这个结果应该是他把系统调用等一些特征移出去得到的结果。最后考虑模型下面的指标，选择了XGBoost作为模型来预测状态。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20211206201122540.png" alt="image-20211206201122540"></p>
<h3 id="和现有工作做对比"><a href="#和现有工作做对比" class="headerlink" title="和现有工作做对比"></a>和现有工作做对比</h3><p>作者将自己的工作和现有的先进路径选择策略做了对比。这些策略包含KLEE Coverage（2008），KLEE Random（2008），AEG Loop Exhaustion（2011）。感觉都挺老的，说明现在没有什么更先进的路径选择策略。</p>
<p>从结果来看，作者的方法更加通用，能测试更多的有漏洞的二进制。但也不是所有的都能跑通。有的时间上也比传统的启发式方法要更慢。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20211206202852245.png" alt="image-20211206202852245"></p>
<p>作者也整理了一下时间维度的对比。随着时间的增加，作者的方法能跑出更多的crash。在相同时间内能跑出的crash的数量和其他传统方法差不多。另外，这种路径选择方式更加通用，不局限于特定的漏洞种类。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20211206203433675.png" alt="image-20211206203433675"></p>
<h3 id="score-分析"><a href="#score-分析" class="headerlink" title="score 分析"></a>score 分析</h3><p>有点不太清楚这个score是什么，是如何计算的？</p>
<p>在探索时分析syml的score的分布情况，期望在探索到漏洞时候分数增加，反之则减小。作者发现这里分数分布和漏洞发现的模式很相同。在刚开始，分数很不稳定，也偏低。分数在崩溃点之后会进入一个谷底，然后又是一段平稳期。随后，分数又变高了，意味着程序在离崩溃点很近的位置或者其他有趣的地方开始探索了。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20211206205106545.png" alt="image-20211206205106545"></p>
<h3 id="应用到真实程序里"><a href="#应用到真实程序里" class="headerlink" title="应用到真实程序里"></a>应用到真实程序里</h3><p>作者将方法应用到三个真实的linux二进制里，asp2php，o3read，ringtonetools。这三个程序代码量都不大，万行左右的代码量级。</p>
<p>在真实程序里测试的结果不是很理想。数据都偏低。因此，作者将CGC上训练好的模型和linux程序一起学习，性能得到了一定的提升。但还是属于一个比较偏低的水平。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20211206210615013.png" alt="image-20211206210615013"></p>
<p>横坐标表示程序执行的情况。0表示刚从程序开始运行，100表示运行到漏洞点了。</p>
<p><img src="https://csdn-imgsumbit.oss-cn-beijing.aliyuncs.com/img/image-20211206210926417.png" alt="image-20211206210926417"></p>
<h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><p>作者认为这是第一个机器学习方法应用到符号执行引擎里的分支选择里。刚好今年的CCS 2021年也出了一篇类似的，通过提取分支的特征，来训练机器学习模型，从而进一步去指导符号执行。</p>
<p>最大的缺陷就是在真实的linux程序上的效果很差。Learning to Explore Paths for Symbolic Execution</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>将符号执行里的分支选择问题，当作是二分类问题来看待。</p>
<p>利用现有的PoC的trace，沿着trace进行符号执行来收集特征信息，训练好模型，利用训练好的模型来选择状态。</p>
<p>相比启发式规则，更加通用。能够挖掘漏洞的类型取决于训练的数据集。</p>
<p>研究方法看起来相对复杂。但理清了思路感觉还是比较有创新性的。</p>
<p>如果能够应用到更多的真实程序里，应该能够发顶会。</p>
<hr>
<p>其他：</p>
<p>RAID 属于安全领域的四小顶会。也算是个水平比较高的会议了。</p>
<p>讲这篇B会是想让大家感受下B会的论文的水平是怎么样的。</p>
<p>总的来说，B会的论文，可能实验效果在真实程序上不理想，但至少实验是相对来说比较完整的。各个小实验里能够支撑论文的点，并且都有些很有意思的发现。</p>
]]></content>
      <tags>
        <tag>paper</tag>
      </tags>
  </entry>
</search>
